"""""
XMSS
"""""

Analysierte Varianten:

- SHA-256, n = 192 Bit
- SHAKE256, n = 256 Bit
- SHA-512, n = 512 Bit

Die Variable *n* definiert die Ausgabelänge der verwendeten Hashfunktion.
Die Ausgabe wird also gegebenenfalls gekürzt.

Für die Analyse von XMSS wurde ein Hilfsprogramm geschrieben, das ähnlich wie das Botan CLI die zu analysierenden Funktionen aufruft.
Für die Erstellung der Signatur wird folgender Aufruf verwendet:

.. code-block:: cpp

    Botan::XMSS_PrivateKey priv_key(priv_key_bits);

    Botan::PK_Signer sig(priv_key, rng, str_mode);
    signature = sig.sign_message(message, rng);

**Modifikation der Merkle Baumhöhe**

Die Laufzeit der Erstellung einer Signatur hängt von der Höhe des Merkle-Baumes ab.
Um die Laufzeit zu reduzieren, wurde ein zusätzlicher, minimaler Parameter für die Merkle-Baumhöhe mit dem Wert zwei hinzugefügt.
Diese Änderung hat keinen Einfluss auf die Ergebnisse der durchgeführten Seitenkanal-Leakage-Analyse.

**Leak: Hash-Ketten Berechnung**

Bei der Analyse wurde ein Kontrollfluss-Leak in der Funktion `chain()` [BOTAN_XMSS_CHAIN]_ gefunden.
Diese Funktion ist Teil des Winternitz One-Time Signature (WOTS) Verfahrens.
Das WOTS-Verfahren zerlegt den Hash der Nachricht in einzelne Teile und signiert diese jeweils durch Berechnung von Hash-Ketten.
Der Input dieser Hash-Ketten ist der private Schlüssel.
Die Anzahl der Schritte der Hash-Ketten-Berechnung entspricht dem Wert des jeweiligen Teils des Nachrichtenhashes.
Der Kontrollfluss-Leak weist auf diese Unterschiede in der Ausführung hin.

.. code-block:: cpp

    void chain(const XMSS_WOTS_Parameters& params,
               secure_vector<uint8_t>& result,
               size_t start_idx,
               size_t steps,
               XMSS_Address& adrs,
               std::span<const uint8_t> seed,
               XMSS_Hash& hash)
    {
    ...
    for(size_t i = start_idx;
          i < (start_idx + steps) && i < params.wots_parameter();
          i++)
       {
       ...
       }
    }

Die Variablen *start_idx* und *steps* geben den Start und die Anzahl der Schritte in der Hashketten-Berechnung vor.
Je nach Wert des Nachrichtenhashes wird daher die *for*-Schleife unterschiedlich oft ausgeführt.
Das ist die Grundlage des beobachteten Kontrollfluss-Leaks.
Dieses Leak manifestiert sich in der Analyse, da das XMSS-Verfahren den Hash einer Nachricht mittels *randomized hashing* [NIST_SP_800_208]_ berechnet.
Dies verhindert generische Kollisionsangriffe und erhöht damit die Sicherheit des Verfahrens erheblich.
Beim *randomized hashing* wird für jede Nachricht eine zufällige Zeichenfolge, das *Salt*, gewählt.
Diese Zeichenfolge wird zusammen mit dem öffentlichen Schlüssel der Nachricht vorangestellt.
Anschließend wird der Hash aller Daten berechnet und in den weiteren Algorithmusschritten verwendet.
Folgender Codeausschnitt zeigt dieses Verfahren in der Botan Implementierung [BOTAN_XMSS_MSG_INIT]_:

.. code-block:: cpp

    void XMSS_Hash::h_msg_init(std::span<const uint8_t> randomness,
                               std::span<const uint8_t> root,
                               std::span<const uint8_t> index_bytes)
       {
       m_msg_hash->clear();
       m_msg_hash->update(m_zero_padding);
       m_msg_hash->update(0x02);
       m_msg_hash->update(randomness.data(), randomness.size());
       m_msg_hash->update(root.data(), root.size());
       m_msg_hash->update(index_bytes.data(), index_bytes.size());
       }

Dementsprechend kommt es auch bei konstanter Nachricht und konstantem, öffentlichen Schlüssel zu unterschiedlichen Hashes, die signiert werden.
Dies führt zu unterschiedlich vielen Schritten in den Hash-Ketten, damit zu unterschiedlichen Verteilungen der beobachteten Adressen und folglich zum Kontrollfluss-Leak, das DATA in Phase 2 identifiziert.
Dieses Leak gibt jedoch nur Informationen über den berechneten Hash preis und nicht über die Daten, auf denen der Hash basiert.
Diese Daten sind das zufällig gewählte Salt, der öffentliche Schlüssel und die zu signierende Nachricht.
Aus diesem Grund ist das hier identifizierte Kontrollfluss-Leak als unproblematisch einzustufen.

In den verwendeten Hash-Funktionen SHA-256, SHA-512 und SHAKE256 wurden keine Leaks identifiziert.
Der private Schlüssel ist damit während der Signaturerstellung von keinem Leak betroffen.

