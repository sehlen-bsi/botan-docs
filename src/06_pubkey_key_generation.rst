.. _pubkey_key_generation/main:

Key Generation for Public Key Algorithms
========================================

DH
--

The implementation of the Diffie-Hellmann key exchange in
``src/lib/pubkey/dh/dh.cpp`` provides the DH public key class
``DH_PublicKey`` and the DH private key class ``DH_PrivateKey``. The public
key consists of the DH parameters and a public value ``y``. In addition to
the public values, the DH private key includes the private parameter
``x``. The algorithm requires both participating parties to generate a DH
private key with the same input discrete logarithm group. A private and
an associated public key is generated by calling the constructor
``DH_PrivateKey(RandomNumberGenerator& rng,const DL_Group& grp,const
BigInt& x_arg = 0)``, where ``x_arg`` of 0 has to be passed to generate a
new private parameter. Otherwise ``x_arg`` is set as the secret value of
the ``DH_PrivateKey``. The key generation algorithm operates as follows:

.. admonition:: ``DH_PrivateKey()``

   **Input:**

   -  ``rng``: random number generator
   -  ``grp``: ``DL_Group`` (**Z**/*p*\ **Z**)* defined by ``p``, generator ``g`` with order ``q``
   -  ``x_arg``: private DH parameter

   **Output:**

   -  DH_PrivateKey: ``x``, ``y``, DL_Group (**Z**/*p*\ **Z**)\* defined by ``p``,
      generator ``g`` with order ``q``

   **Steps:**

   1. If ``x_arg`` was provided, set ``x`` to ``x_arg``. Otherwise:

      -  Determine needed exponent length by calling ``grp.exponent_bits()``.
      -  Sample random number of determined exponent length from random
         number generator ``rng`` as secret DH value ``x``.

   2. Compute ``y`` as :math:`g^x \bmod p` with ``g`` and ``p`` taken from the input group ``grp``.

      Optionally the generated parameters and the DL_Group parameters can
      be verified with a call to ``check_key(RandomNumberGenerator& rng,
      bool strong)``. The generated values and the used discrete logarithm
      group ``fail`` the check if one of the following conditions is met.

      -  :math:`y < 2`
      -  :math:`y \geq p`
      -  :math:`x < 2`
      -  :math:`x \geq p`
      -  :math:`g < 2`
      -  :math:`p < 3`
      -  :math:`q < 0`
      -  :math:`{q \neq {{0 \land p} - 1}}\bmod {q \neq 0}`
      -  :math:`{q \neq {0 \land g^{q}}}\bmod {p \neq 1}`
      -  Miller-Rabin primality test for ``p`` or ``q`` fails with 6 (65 if
         ``strong`` is true) test iterations. The test is performed with the
         function ``is_prime()`` for non random numbers.
      -  Lucas primality test of ``p`` or ``q`` fails.
      -  :math:`{y \neq g^{x}}\bmod p`

**Conclusion:** The secret DH parameter is sampled as described in
[TR-02102-1]_.

To avoid potentially malicious system parameters from computational
peers, the ``check_key`` function should be manually called before the key
from the peer has been accepted.

DSA
---

The DSA implementation offers the DSA Key classes ``DSA_PrivateKey`` and
``DSA_PublicKey`` with respective constructors. A DSA public key consists
of a discrete logarithmic group (DH parameter) and a public value ``y``.
The associated private key contains an additional private parameter ``x``.
A ``DSA_PrivateKey`` can be generated with the constructor
``DSA_PrivateKey(RandomNumberGenerator& rng, const DL_Group& grp, const
BigInt& x_arg)``. The implementation operates as follows:

.. admonition:: ``DSA_PrivateKey()``

   **Input:**

   -  ``rng``: random number generator
   -  ``grp``: DL_Group (**Z**/*p*\ **Z**)\* : ``p``, generator ``g`` with order
      ``q``
   -  ``x_arg``: private DSA parameter

   **Output:**

   -  DSA_PrivateKey: ``x``, ``y``, DL_Group (**Z**/*p*\ **Z**)\* : ``p``,
      generator ``g`` with order ``q``

   **Steps:**

   1. If private value ``x_arg`` was provided, set ``x`` to ``x_arg``. Otherwise,
      sample ``x`` as a random number :math:`r<x<q-1` from ``rng`` using the algorithm
      described in Section :ref:`pubkey_param/rng`.
   2. Compute public value ``y`` as :math:`g^x \bmod{p}`

      Optional verification of the generated key with
      ``check_key(RandomNumberGenerator& rng, bool strong)``. See DH key
      generation check.

Elliptic Curve Algorithms
-------------------------

Botan provides the elliptic curve private key class ``EC_PrivateKey``, the
respective public key class ``EC_PublicKey``, and the key generation
algorithm in ``src/lib/pubkey/ecc_key/ecc_key.cpp``. To generate a private
key the constructor ``EC_PrivateKey(RandomNumberGenerator& rng, const
EC_Group& ec_group, const BigInt& x, bool with_modular_inverse)`` is
called. The constructor operates as follows:

.. admonition:: ``EC_PrivateKey()``

   **Input:**

   -  ``rng``: random number generator
   -  ``ec_group``: domain(curve parameters(first coefficient a, second
      coefficient b, prime p), base point G, ord(G) n, cofactor of the
      curve h)

   **Output:**

   -  EC_Privatekey: ``d``, ``Q``, domain(curve parameters(first coefficient a,
      second coefficient b, prime p), base point G, ord(G) n, cofactor of
      the curve h)

   **Steps:**

   1. Sample private value ``d`` as a random number :math:`1 \leq d < n` using the algorithm
      described in Section :ref:`pubkey_param/rng`, where :math:`n` is the order of the
      base point G on the curve taken from the domain parameters. It is
      also possible to pass ``d`` as ``x`` to the constructor. In this case ``d``
      is not sampled.
   2. Compute public point ``Q`` as point multiplication :math:`d*G`, where ``G`` is the
      base point defined in the domain. Note that if the passed parameter
      ``with_modular_inverse`` is set to ``true``, the public point ``Q`` is
      instead computed as :math:`d^{-1}*G`. This is required for ECKDSA and ECGDSA key
      generation, but results in an invalid ECDH/ECDSA key.
   3. Verify that the computed public point ``Q`` is on the curve (function
      ``on_the_curve()``). As a consequence, the key generation algorithm
      resists fault attacks and computational errors.

Optionally ``EC_PublicKeys`` can be extensively checked with a call to
``check_key``. The extensive check performs the following steps. Note that
``on_the_curve()`` is always automatically checked.

.. admonition:: ``EC_PublicKeys::check_key()``

   1. Verify the ``ec_group`` by calling ``EC_Group::verify_group``. If the
      domain does not pass the verification, return false.
   2. Assure that the public point ``Q`` is not the point at infinity.
   3. Check that the public point ``Q`` is on the curve (function
      ``on_the_curve()``). If the point does not satisfy the curve equation,
      return false.
   4. If :math:`h>1` applies perform the following additional steps. Else return true.

      1. Verify that the public point has the correct order ``n``. This is
         the case if :math:`h*Q \neq_\infty P` and apply :math:`n*Q =_\infty P`.
         If one of the equations does not apply,
         return false.
      2. Return true.

**Conclusion:** The algorithm fulfills all requirements of [TR-03111]_.
The public key validation follows the requirements described in [ReqEC]_.

RSA
---

The appropriate RSA key pair constructor
``RSA_PrivateKey(RandomNumberGenerator& rng,size_t bits, size_t exp =
65537)`` of class RSA_PrivateKey is called when generating a new RSA key
pair. ``rng`` is a random number generator, ``bits`` the desired bit length
of the modulus ``N`` and ``exp`` the public exponent to be used.

The key generation process works as follows:

.. admonition:: ``RSA_PrivateKey()``

   **Input:**

   -  ``rng``: random number generator
   -  ``bits``: bit length of RSA modulus ``N``
   -  ``e``: public exponent

   **Output:**

   -  ``RSA_PrivateKey``: the first prime ``p``, the second prime ``q``, the public exponent ``e``,
      the modulus ``N``, the private exponent ``d``, and the additional values for CRT-RSA :math:`d_1`, :math:`d_2`, and :math:`c` (see below)

   **Steps:**

   1. The algorithm initially checks if the passed key length is at least
      1024. If this is not the case, the function terminates with an error
      message. Thus, only keys with a desired length of at least 1024 bits
      can be generated.
   2. Subsequently the passed exponent is validated, as it must be odd and
      larger than 2.
   3. If this step is reached the 10th time the generation fails.
      The algorithm samples 2 primes by successively calling
      ``generate_rsa_prime()`` from ``src/lib/math/numbertheory/make_prm.cpp``,
      passing the public exponent as ``coprime``. The first prime ``p`` has a
      bit length of :math:`\lceil \frac{bits}{2} \rceil` and the second prime ``q`` is
      :math:`\lfloor \frac{bits}{2} \rfloor` long.
   4. If the difference between ``p`` and ``q`` is not at least :math:`2^{bits/2 - 100}`,
      go to step 3.
   5. If the product of the resulting primes ``N`` has not the specified bit
      length, go to step 3.
   6. The private exponent ``d`` is computed as :math:`e^{-1} \bmod \text{lcm}(p-1,q-1)`. For this purpose, the
      extended Euclidean algorithm, implemented in
      ``src/lib/math/numbertheory/numthry.cpp``, is used.

   7. Additional values needed for CRT-RSA are computed as follows.

      -  :math:`{d_{1} = d}\bmod {({p - 1})}`
      -  :math:`{d_{2} = d}\bmod {({q - 1})}`
      -  :math:`{c = q^{- 1}}\bmod p`

      The key values can be manually checked for consistency with the
      ``check_key(RandomNumberGenerator& rng, bool strong)`` function. The
      key pair fails the check if one of the following conditions is met:

      -  :math:`N < 35`
      -  :math:`N\bmod {2 = 0}`
      -  :math:`e < 3`
      -  :math:`e\bmod {2 = 0}`
      -  :math:`d < 2`
      -  :math:`p < 3`
      -  :math:`q < 3`
      -  :math:`{p \ast q} \neq N`
      -  :math:`{d_{1} \neq d}\bmod {({p - 1})}`
      -  :math:`{d_{2} \neq d}\bmod {({q - 1})}`
      -  :math:`{c \neq q^{- 1}}\bmod p`
      -  Miller-Rabin primality test of ``p`` or ``q`` fails with 7 (65 if
         ``strong`` is true) test iterations. The test is performed with the
         function ``is_prime()`` for non random numbers.
      -  Lucas primality test of ``p`` or ``q`` fails.
      -  Only if ``strong`` is true:

         -  :math:`{e \ast d}\bmod \mathit{lcm}{{({{p - 1},{q - 1}})} \neq 1}`
         -  The creation and verification of a test signature fails
            (``signature_consistency_check()``)

**Remark:**
The algorithm slightly deviates from the method outlined in [TR-02102-1]_
in that the interval used for the prime generation depends on the parity of ``bits``
and :math:`p` and :math:`q` are chosen to be congruent to :math:`3` modulo :math:`4`.
However, the interval is still sufficiently large and since about 25% of all pairs of odd primes satisfy the congruence condition,
it is not expected that this restriction affects the security of the resulting RSA keys.

**Conclusion:** The algorithm fulfills all main requirements listed in
[TR-02102-1]_. The minimum possible bit length of the modulus N should be
increased to the recommendation of 2000 bit.

XMSS with WOTS+
---------------

Botan implements the single tree version of the eXtended Merkle
Signature Scheme (XMSS) using Winternitz One Time Signatures+ (WOTS+) in
``src/lib/pubkey/xmss/``. The implementation is based on RFC8391 [XMSS]_.
The list of supported algorithms and their parameters is depicted in
Table :ref:`Supported XMSS Signature algorithms <pubkey_key_generation/xmss/table>`.

.. _pubkey_key_generation/xmss/table:

.. table::  Supported XMSS Signature algorithms and their parameters (see Section 5.3 in [XMSS]_)

   +-------------------+----+----+-----+----+
   |                   | Parameters         |
   |                   +----+----+-----+----+
   | XMSS algorithm    | n  | w  | len | h  |
   +===================+====+====+=====+====+
   | XMSS-SHA2_10_256  | 32 | 16 | 67  | 10 |
   +-------------------+----+----+-----+----+
   | XMSS-SHA2_16_256  | 32 | 16 | 67  | 16 |
   +-------------------+----+----+-----+----+
   | XMSS-SHA2_20_256  | 32 | 16 | 67  | 20 |
   +-------------------+----+----+-----+----+
   | XMSS-SHA2_10_512  | 64 | 16 | 131 | 10 |
   +-------------------+----+----+-----+----+
   | XMSS-SHA2_16_512  | 64 | 16 | 131 | 16 |
   +-------------------+----+----+-----+----+
   | XMSS-SHA2_20_512  | 64 | 16 | 131 | 20 |
   +-------------------+----+----+-----+----+
   | XMSS-SHAKE_10_256 | 32 | 16 | 67  | 10 |
   +-------------------+----+----+-----+----+
   | XMSS-SHAKE_16_256 | 32 | 16 | 67  | 16 |
   +-------------------+----+----+-----+----+
   | XMSS-SHAKE_20_256 | 32 | 16 | 67  | 20 |
   +-------------------+----+----+-----+----+
   | XMSS-SHAKE_10_512 | 64 | 16 | 131 | 10 |
   +-------------------+----+----+-----+----+
   | XMSS-SHAKE_16_512 | 64 | 16 | 131 | 16 |
   +-------------------+----+----+-----+----+
   | XMSS-SHAKE_20_512 | 64 | 16 | 131 | 20 |
   +-------------------+----+----+-----+----+

XMSS and WOTS+ rely on the hash function address scheme (``ADRS``). This
scheme consists of 256 bits and stores OTS hash addresses and hash tree
addresses, see Section 2.5 in [XMSS]_. ``ADRS`` is implemented in
``src/lib/pubkey/xmss/xmss_address.h`` and offers the following setter methods.
The respective getter methods were left out for readability:

-  ``set_key_mask_mode(Key_Mode=0 / Mask_Mode=1, Mask_LSB_Mode=1,
   Mask_MSB_Mode=2)``
-  ``set_chain_address(i)``
-  ``set_hash_address(i)``
-  ``set_ots_address(i)``
-  ``set_ltree_address(i)``
-  ``set_type(OTS Hash Address / L-Tree Address / Hash Tree Address)``
-  ``set_tree_height(i)``
-  ``set_tree_index(i)``

XMSS and WOTS+ use a specific **base w** number representation. For
example, this representation turns a string ``X=0x1234`` into a byte array
``{1,2,3,4}=base_w(X, 16, 4)``. We refer to Section 2.6, Algorithm 1
[XMSS]_ for more details.

WOTS+
~~~~~

WOTS+ uses a chaining function ``chain(X,i,s,ADRS,seed)`` to iteratively
execute ``s`` PRF calls on a given input string ``X``, the start index ``i``,
number of steps ``s``, combined with ``ADRS`` and a ``seed`` value. See
Algorithm 2 in [XMSS]_ for more details.

WOTS+ and in particular the ``chain`` function are implemented in
``src/lib/pubkey/xmss/xmss_wots_privatekey.cpp`` and ``src/lib/pubkey/xmss/xmss_wots_publickey.cpp``.

Botan's ``XMSS_WOTS_PrivateKey`` class is not named intuitively. It encapsulates
the ``private_seed`` and on-demand WOTS+ key generation primitives (for XMSS's leaf nodes). Objects of this class *do not* embody a single WOTS+ leaf node.

Hence, the key generation of WOTS+ keys is split into two phases:

.. admonition:: WOTS+ key generator initialization

   **Input:**

   -  ``rng``: random number generator
   -  ``oid``: XMSS WOTS+ parameters (``n``, ``w``, ``len``, ``PRF``), see Table :ref:`Supported XMSS Signature algorithms <pubkey_key_generation/xmss/table>`
   -  ``public_seed``: public seed used for the pseudo random generation of
      public keys derived from the generated private key [#wots_optional_seed]_

   **Output:**

   -  ``XMSS_WOTS_PrivateKey``: containing the ``private_seed`` and ``public_seed``

   **Steps:**

   1. Use ``rng`` to generate ``private_seed`` of length ``n``.

   **Notes:**

   - This is implemented in the ``XMSS_WOTS_PrivateKey`` constructor in
     ``src/lib/pubkey/xmss/xmss_wots.h``
   - The constructor of ``XMSS_WOTS_PrivateKey`` derives an ``sk`` and ``pk``
     from the newly generated seeds. Though, they are unused in the XMSS use-case.

.. admonition:: WOTS+ leaf node key generation

   **Input:**

   - ``ADRS``: address of the leaf node key to be generated
   - ``oid``: XMSS WOTS+ parameters (``n``, ``w``, ``len``, ``PRF``)
   - ``private_seed``: private seed to derive WOTS+ private keys from (generated above)
   - ``public_seed``: public seed (see above)

   **Output:**

   - ``sk`` and ``pk`` of the WOTS+ leaf node

   **Steps:**

   1. | Derive a unique ``wots_seed`` as: ``PRF(private_seed, ADRS)``
      | (see ``XMSS_WOTS_PrivateKey::at()``)
   2. | Generate ``sk[i]`` with ``i`` from 0 to ``len`` as: ``PRF(wots_seed, i)``
      | (see ``XMSS_WOTS_PrivateKey::generate()``)
   3. | Derive the ``pk[i]`` from ``sk[i]`` as: ``chain(sk[i], 0, w-1, ADRS', public_seed)``
      | where ``ADRS' = ADRS.set_chain_address(i)``
      | (see ``XMSS_WOTS_PrivateKey::generate_public_key()``)

   **Notes:**

   - All referenced methods above are implemented in ``src/lib/pubkey/xmss/xmss_wots_privatekey.cpp`` and are orchestrated in ``src/lib/pubkey/xmss/xmss_privatekey.cpp``.

.. _pubkey_key_generation/xmss/remark_nist_sp800208:

**Remark:** Botan derives WOTS+ private keys from the ``private_seed`` as
described in RFC8391 [XMSS]_ which is prone to a multi-target attack. NIST SP.800-208
Section 6.2 [NIST-HashSigs]_ recommends an adapted key generation procedure as a
counter-measure. This is currently not implemented in Botan.

.. [#wots_optional_seed]
   The ``public_seed`` can optionally be generated using the RNG.

XMSS
~~~~

XMSS functionality is implemented in
``src/lib/pubkey/xmss/xmss_privatekey.cpp`` and
``src/lib/pubkey/xmss/xmss_publickey.cpp``.

The algorithm for key generation relies on the method ``treeHash`` from
Algorithm 9 in [XMSS]_. The ``treeHash`` method takes as input secret key
``sk``, start index ``s``, target node height ``t``, and address ``ADRS``. The
algorithm uses the input parameters and the secret key ``sk`` stored in
the XMSS_PrivateKey object to return the root node of a given tree,
whose height is ``t``. The index s represents the index of the left most
leaf of the WOTS+ public key. Botan implements the function as described
in Algorithm 9.

Based on the ``treeHash`` function the key generation process follows
Algorithm 10 in [XMSS]_ and it works as follows:

.. admonition:: XMSS key generation

   **Input:**

   -  ``rng``: random number generator
   -  ``xmss_algo_id``: XMSS signature parameter identifier (``n``, ``w``, ``len``,
      ``PRF``), see Table :ref:`Supported XMSS Signature algorithms <pubkey_key_generation/xmss/table>`

   **Output:**

   -  ``XMSS_PrivateKey``: ``SK``, ``PK``

   **Steps:**

   1. Generate new ``public_seed`` and ``SK_PRF`` seed using ``rng``. Each seed
      has length ``n``.
   2. | Initialize WOTS+ key generator with ``public_seed`` and ``private_seed``
      | (see the algorithm from previous section).
   3. Initiate the index registry with ``idx=0``. This value references the
      first unused leaf index.
   4. Compute the ``root`` node value by walking through the entire XMSS tree
      using the ``treeHash`` function (Algorithm 9 in [XMSS]_). This derives all
      WOTS+ leaf nodes using the generation algorithm described above.

      ``root = treeHash(0, h, ADRS);``

   5. | ``SK = {idx, SK_PRF, root, public_seed}``
      | ``PK = {root, public_seed}``

   **Notes:**

   - The generation procedure is implemented in ``src/lib/pubkey/xmss/xmss_privatekey.cpp``
     in the ``XMSS_PrivateKey()`` constructor and ``XMSS_PrivateKey::tree_hash()``
     as well as ``XMSS_PrivateKey::tree_hash_subtree()``

**Remark:** Note that Botan does not store the whole XMSS keys in
memory. Only ``public_seed``, ``private_seed``, and ``SK_PRF`` are stored, and
are used to construct keys on demand. See also Section 4.1.11 in [XMSS]_.

.. _pubkey_key_generation/xmss/Remark_02:

**Remark:** XMSS is based on the repeated application of a hash function to
secret key material. In order to conduct a successful timing-based side
channel attack, an attacker needs to be able to calculate the hash
value's pre images by observing the timing behavior of the involved
processes. If such a side-channel exists in the implementation of the
hash function, an attacker can exploit it even in a single threaded
setting.

Specifically, in Botan's (multi-threaded) implementation of the XMSS hash tree
another (harmless) side channel may arise:

By observing the system load or the number of active threads, an
attacker can infer the location in the hash tree structure that the
currently running computations are working on. Depending on the
parameters, the key generation and the signature computation are running
in constant time on identical hardware if the hash function computations
run in constant time. Therefore, an attacker can infer the position in
the tree that the algorithm is currently working on even if only a
single thread is used.

.. _pubkey_key_generation/kyber:

Kyber
-----

Botan implements the CRYSTALS-Kyber KEM in
``src/lib/pubkey/kyber/``. The implementation is based on the NIST round 3 specification [Kyber-R3]_.
The list of supported algorithms and their parameters is depicted in
Table :ref:`Supported Kyber parameter sets <pubkey_key_generation/kyber/table>`.
All possible modes are represented by the class ``KyberMode`` found in ``src/lib/pubkey/kyber/kyber_common``.
The ``_90s`` suffix denotes different symmetric functions for Kyber's \"90's mode\".
These symmetric functions are represented by an adapter class ``Kyber_Symmetric_Primitives``, realized in ``src/lib/pubkey/kyber/kyber`` for modern Kyber modes and ``src/lib/pubkey/kyber/kyber_90s`` for the 90's variants.
For each mode, the ``KyberConstants`` class contains the corresponding set of parameters and symmetric functions (``Kyber_Symmetric_Primitives``).

.. _pubkey_key_generation/kyber/table:

.. table::  Supported Kyber parameter sets (see Section 1.4 in [Kyber-R3]_)

   +-------------------+----+----+-----+--------------+----------------+--------------+----------+-----------+--------------+------------+
   |                   | Parameters                                    | Symmetric Functions                                             |
   |                   +----+----+-----+--------------+----------------+--------------+----------+-----------+--------------+------------+
   |  Mode             | N  | k  | Q   | eta1         |         eta2   | XOF          | H        | G         | PRF          | KDF        |
   +===================+====+====+=====+==============+================+==============+==========+===========+==============+============+
   | Kyber512          | 256| 2  | 3329| 3            |   2            |SHAKE-128     | SHA3-256 | SHA3-512  | SHAKE-256    | SHAKE-256  |
   +-------------------+----+----+-----+--------------+----------------+--------------+----------+-----------+--------------+------------+
   | Kyber512 90s      | 256| 2  | 3329| 3            |   2            |AES-256-CTR   | SHA-256  | SHA512    | AES-256-CTR  | SHA-256    |
   +-------------------+----+----+-----+--------------+----------------+--------------+----------+-----------+--------------+------------+
   | Kyber768          | 256| 3  | 3329| 2            |   2            |SHAKE-128     | SHA3-256 | SHA3-512  | SHAKE-256    | SHAKE-256  |
   +-------------------+----+----+-----+--------------+----------------+--------------+----------+-----------+--------------+------------+
   | Kyber768 90s      | 256| 3  | 3329| 2            |   2            |AES-256-CTR   | SHA-256  | SHA-512   | AES-256-CTR  | SHA-256    |
   +-------------------+----+----+-----+--------------+----------------+--------------+----------+-----------+--------------+------------+
   | Kyber1024         | 256| 4  | 3329| 2            |   2            |SHAKE-128     | SHA3-256 | SHA3-512  | SHAKE-256    | SHAKE-256  |
   +-------------------+----+----+-----+--------------+----------------+--------------+----------+-----------+--------------+------------+
   | Kyber1024 90s     | 256| 4  | 3329| 2            |   2            |AES-256-CTR   | SHA-256  | SHA-512   | AES-256-CTR  | SHA-256    |
   +-------------------+----+----+-----+--------------+----------------+--------------+----------+-----------+--------------+------------+

Kyber itself is implemented in ``src/lib/pubkey/kyber/kyber_common/kyber.cpp``.
Basic representations and operations on polynomials, polynomial vectors, and polynomial matrices are given via the ``Polynomial``, ``PolynomialVector``, and ``PolynomialMatrix`` classes, respectively.
``Polynomial`` and ``PolynomialVector`` support member functions ``.ntt()`` and ``.invntt()`` for the number-theoretic transform (NTT; see more details in Section 1.1 of [Kyber-R3]_) and fast multiplication in the NTT domain.
Multiplication of two polynomial vectors in NTT domain ``a*b`` is given via the function ``PolynomialVector::pointwise_acc_montgomery`` using Montgomery reduction.
Note that ``.invntt()`` here is called ``.invntt_tomont()`` in the implementation as it directly multiplies by the Montgomery factor.

Additionally, ``PolynomialMatrix`` has a member function ``generate(seed, transposed, mode)``, which generates a (possibly transposed) ``k``:math:`\times`\ ``k`` matrix ``a`` from the ``seed`` given a ``mode``.
The matrix is already generated in the NTT domain via rejection sampling with ``XOF`` (using the function ``Polynomial::sample_rej_uniform(XOF)`` that corresponds to **Algorithm 1** of [Kyber-R3]_).

**Algorithm 2** of [Kyber-R3]_ is implemented via the member function ``Polynomial::getnoise_cbd2``  for the case ``eta1=2`` (and a respective version for ``eta1=3``). It deterministically samples noise from a centered binomial distribution.

Encoding/decoding of polynomials (**Algorithm 3** of [Kyber-R3]_) is realized via the ``Polynomial::to_bytes()``/ ``Polynomial::from_bytes()`` functions.

Based on these functions the key generation process follows **Algorithms 4 and 7** of [Kyber-R3]_ and works as follows:

.. admonition:: Kyber_PrivateKey::Kyber_PrivateKey()

   **Input:**

   -  ``rng``: random number generator
   -  ``m``: Kyber mode providing (``N``, ``k``, ``Q``, ``XOF``, ``H``, ``G``, ``PRF``, ``KDF``), see Table :ref:`Supported Kyber parameter sets <pubkey_key_generation/kyber/table>`

   **Output:**

   -  ``sk``: ``Kyber_PrivateKeyInternal``
   -  ``pk``: ``Kyber_PublicKeyInternal``

   **Steps:**

   1. ``(seed1 || seed2) = G(d)`` where d is generated using ``rng`` and each seed has the same length (L. 1-2, Alg. 4 [Kyber-R3]_)
   2. ``a = PolynomialMatrix::generate(seed1, false, m)`` (L. 4-8, Alg. 4 [Kyber-R3]_)
   3. ``s = PolynomialVector::getnoise_eta1(seed2, 0, m)`` (performs ``k`` invocations of ``Polynomial::getnoise_eta1`` for each vector element; L. 9-12, Alg. 4 [Kyber-R3]_)
   4. ``e = PolynomialVector::getnoise_eta1(seed2, k, m)`` (L. 13-16, Alg. 4 [Kyber-R3]_)
   5. ``s.ntt()`` and ``e.ntt()`` (L. 17-18, Alg. 4 [Kyber-R3]_)
   6. ``pk = (a*s + e, seed1)`` and ``sk = (s, pk, H(pk), z)`` where ``z`` is freshly generated with ``rng`` (L. 19-22, Alg. 4 [Kyber-R3]_ and L.1, 3, Alg. 7 [Kyber-R3]_)

   **Notes:**

   - The member function ``Polynomial::getnoise_eta1(seed, nonce, mode)`` uses ``PRF`` on the seed with incremented nonce values to call ``Polynomial::getnoise_cbd2`` or ``Polynomial::getnoise_cbd3`` depending on ``eta1``.
   - Serialization to bytes of the keys (:math:`\textrm{Encode}` in L.20, 21, Alg. 4 [Kyber-R3]_) is performed via the constructor of ``Kyber_PublicKeyInternal`` (resp. ``Kyber_PrivateKeyInternal``) by calling ``Polynomial::to_bytes()``.
