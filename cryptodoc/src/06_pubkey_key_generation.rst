.. _pubkey_key_generation/main:

Key Generation for Public Key Algorithms
========================================

DH
--

The implementation of the Diffie-Hellmann key exchange in
:srcref:`src/lib/pubkey/dh/dh.cpp` provides the DH public key class
``DH_PublicKey`` and the DH private key class ``DH_PrivateKey``. The public
key consists of the DH parameters and a public value ``y``. In addition to
the public values, the DH private key includes the private parameter
``x``. The algorithm requires both participating parties to generate a DH
private key with the same input discrete logarithm group. A private and
an associated public key is generated by calling the constructor
``DH_PrivateKey(RandomNumberGenerator& rng,const DL_Group& grp,const
BigInt& x_arg = 0)``, where ``x_arg`` of 0 has to be passed to generate a
new private parameter. Otherwise ``x_arg`` is set as the secret value of
the ``DH_PrivateKey``. The key generation algorithm operates as follows:

.. admonition:: ``DH_PrivateKey()``

   **Input:**

   -  ``rng``: random number generator
   -  ``grp``: ``DL_Group`` (**Z**/*p*\ **Z**)* defined by ``p``, generator ``g`` with order ``q``
   -  ``x_arg``: private DH parameter

   **Output:**

   -  DH_PrivateKey: ``x``, ``y``, DL_Group (**Z**/*p*\ **Z**)\* defined by ``p``,
      generator ``g`` with order ``q``

   **Steps:**

   1. If ``x_arg`` was provided, set ``x`` to ``x_arg``. Otherwise:

      -  Determine needed exponent length by calling ``grp.exponent_bits()``.
      -  Sample random number of determined exponent length from random
         number generator ``rng`` as secret DH value ``x``.

   2. Compute ``y`` as :math:`g^x \bmod p` with ``g`` and ``p`` taken from the input group ``grp``.

      Optionally the generated parameters and the DL_Group parameters can
      be verified with a call to ``check_key(RandomNumberGenerator& rng,
      bool strong)``. The generated values and the used discrete logarithm
      group ``fail`` the check if one of the following conditions is met.

      -  :math:`y < 2`
      -  :math:`y \geq p`
      -  :math:`x < 2`
      -  :math:`x \geq p`
      -  :math:`g < 2`
      -  :math:`p < 3`
      -  :math:`q < 0`
      -  :math:`{q \neq {{0 \land p} - 1}}\bmod {q \neq 0}`
      -  :math:`{q \neq {0 \land g^{q}}}\bmod {p \neq 1}`
      -  Miller-Rabin primality test for ``p`` or ``q`` fails with 6 (65 if
         ``strong`` is true) test iterations. The test is performed with the
         function ``is_prime()`` for non random numbers.
      -  Lucas primality test of ``p`` or ``q`` fails.
      -  :math:`{y \neq g^{x}}\bmod p`

**Conclusion:** The secret DH parameter is sampled as described in
[TR-02102-1]_.

To avoid potentially malicious system parameters from computational
peers, the ``check_key`` function should be manually called before the key
from the peer has been accepted.

DSA
---

The DSA implementation offers the DSA Key classes ``DSA_PrivateKey`` and
``DSA_PublicKey`` with respective constructors. A DSA public key consists
of a discrete logarithmic group (DH parameter) and a public value ``y``.
The associated private key contains an additional private parameter ``x``.
A ``DSA_PrivateKey`` can be generated with the constructor
``DSA_PrivateKey(RandomNumberGenerator& rng, const DL_Group& grp, const
BigInt& x_arg)``. The implementation operates as follows:

.. admonition:: ``DSA_PrivateKey()``

   **Input:**

   -  ``rng``: random number generator
   -  ``grp``: DL_Group (**Z**/*p*\ **Z**)\* : ``p``, generator ``g`` with order
      ``q``
   -  ``x_arg``: private DSA parameter

   **Output:**

   -  DSA_PrivateKey: ``x``, ``y``, DL_Group (**Z**/*p*\ **Z**)\* : ``p``,
      generator ``g`` with order ``q``

   **Steps:**

   1. If private value ``x_arg`` was provided, set ``x`` to ``x_arg``. Otherwise,
      sample ``x`` as a random number :math:`r<x<q-1` from ``rng`` using the algorithm
      described in Section :ref:`pubkey_param/rng`.
   2. Compute public value ``y`` as :math:`g^x \bmod{p}`

      Optional verification of the generated key with
      ``check_key(RandomNumberGenerator& rng, bool strong)``. See DH key
      generation check.

Elliptic Curve Algorithms
-------------------------

Botan provides the elliptic curve private key class ``EC_PrivateKey``, the
respective public key class ``EC_PublicKey``, and the key generation
algorithm in :srcref:`src/lib/pubkey/ecc_key/ecc_key.cpp`. To generate a private
key the constructor ``EC_PrivateKey(RandomNumberGenerator& rng, const
EC_Group& ec_group, const BigInt& x, bool with_modular_inverse)`` is
called. The constructor operates as follows:

.. admonition:: ``EC_PrivateKey()``

   **Input:**

   -  ``rng``: random number generator
   -  ``ec_group``: domain(curve parameters(first coefficient a, second
      coefficient b, prime p), base point G, ord(G) n, cofactor of the
      curve h)

   **Output:**

   -  EC_Privatekey: ``d``, ``Q``, domain(curve parameters(first coefficient a,
      second coefficient b, prime p), base point G, ord(G) n, cofactor of
      the curve h)

   **Steps:**

   1. Sample private value ``d`` as a random number :math:`1 \leq d < n` using the algorithm
      described in Section :ref:`pubkey_param/rng`, where :math:`n` is the order of the
      base point G on the curve taken from the domain parameters. It is
      also possible to pass ``d`` as ``x`` to the constructor. In this case ``d``
      is not sampled.
   2. Compute public point ``Q`` as point multiplication :math:`d*G`, where ``G`` is the
      base point defined in the domain. Note that if the passed parameter
      ``with_modular_inverse`` is set to ``true``, the public point ``Q`` is
      instead computed as :math:`d^{-1}*G`. This is required for ECKDSA and ECGDSA key
      generation, but results in an invalid ECDH/ECDSA key.
   3. Verify that the computed public point ``Q`` is on the curve (function
      ``on_the_curve()``). As a consequence, the key generation algorithm
      resists fault attacks and computational errors.

Optionally ``EC_PublicKeys`` can be extensively checked with a call to
``check_key``. The extensive check performs the following steps. Note that
``on_the_curve()`` is always automatically checked.

.. admonition:: ``EC_PublicKeys::check_key()``

   1. Verify the ``ec_group`` by calling ``EC_Group::verify_group``. If the
      domain does not pass the verification, return false.
   2. Assure that the public point ``Q`` is not the point at infinity.
   3. Check that the public point ``Q`` is on the curve (function
      ``on_the_curve()``). If the point does not satisfy the curve equation,
      return false.
   4. If :math:`h>1` applies perform the following additional steps. Else return true.

      1. Verify that the public point has the correct order ``n``. This is
         the case if :math:`h*Q \neq_\infty P` and apply :math:`n*Q =_\infty P`.
         If one of the equations does not apply,
         return false.
      2. Return true.

**Conclusion:** The algorithm fulfills all requirements of [TR-03111]_.
The public key validation follows the requirements described in [ReqEC]_.

RSA
---

The appropriate RSA key pair constructor
``RSA_PrivateKey(RandomNumberGenerator& rng,size_t bits, size_t exp =
65537)`` of class RSA_PrivateKey is called when generating a new RSA key
pair. ``rng`` is a random number generator, ``bits`` the desired bit length
of the modulus ``N`` and ``exp`` the public exponent to be used.

The key generation process works as follows:

.. admonition:: ``RSA_PrivateKey()``

   **Input:**

   -  ``rng``: random number generator
   -  ``bits``: bit length of RSA modulus ``N``
   -  ``e``: public exponent

   **Output:**

   -  ``RSA_PrivateKey``: the first prime ``p``, the second prime ``q``, the public exponent ``e``,
      the modulus ``N``, the private exponent ``d``, and the additional values for CRT-RSA :math:`d_1`, :math:`d_2`, and :math:`c` (see below)

   **Steps:**

   1. The algorithm initially checks if the passed key length is at least
      1024. If this is not the case, the function terminates with an error
      message. Thus, only keys with a desired length of at least 1024 bits
      can be generated.
   2. Subsequently the passed exponent is validated, as it must be odd and
      larger than 2.
   3. If this step is reached the 10th time the generation fails.
      The algorithm samples 2 primes by successively calling
      ``generate_rsa_prime()`` from :srcref:`src/lib/math/numbertheory/make_prm.cpp`,
      passing the public exponent as ``coprime``. The first prime ``p`` has a
      bit length of :math:`\lceil \frac{bits}{2} \rceil` and the second prime ``q`` is
      :math:`\lfloor \frac{bits}{2} \rfloor` long.
   4. If the difference between ``p`` and ``q`` is not at least :math:`2^{bits/2 - 100}`,
      go to step 3.
   5. If the product of the resulting primes ``N`` has not the specified bit
      length, go to step 3.
   6. The private exponent ``d`` is computed as :math:`e^{-1} \bmod \text{lcm}(p-1,q-1)`. For this purpose, the
      extended Euclidean algorithm, implemented in
      :srcref:`src/lib/math/numbertheory/numthry.cpp`, is used.

   7. Additional values needed for CRT-RSA are computed as follows.

      -  :math:`{d_{1} = d}\bmod {({p - 1})}`
      -  :math:`{d_{2} = d}\bmod {({q - 1})}`
      -  :math:`{c = q^{- 1}}\bmod p`

      The key values can be manually checked for consistency with the
      ``check_key(RandomNumberGenerator& rng, bool strong)`` function. The
      key pair fails the check if one of the following conditions is met:

      -  :math:`N < 35`
      -  :math:`N\bmod {2 = 0}`
      -  :math:`e < 3`
      -  :math:`e\bmod {2 = 0}`
      -  :math:`d < 2`
      -  :math:`p < 3`
      -  :math:`q < 3`
      -  :math:`{p \ast q} \neq N`
      -  :math:`{d_{1} \neq d}\bmod {({p - 1})}`
      -  :math:`{d_{2} \neq d}\bmod {({q - 1})}`
      -  :math:`{c \neq q^{- 1}}\bmod p`
      -  Miller-Rabin primality test of ``p`` or ``q`` fails with 7 (65 if
         ``strong`` is true) test iterations. The test is performed with the
         function ``is_prime()`` for non random numbers.
      -  Lucas primality test of ``p`` or ``q`` fails.
      -  Only if ``strong`` is true:

         -  :math:`{e \ast d}\bmod \mathit{lcm}{{({{p - 1},{q - 1}})} \neq 1}`
         -  The creation and verification of a test signature fails
            (``signature_consistency_check()``)

**Remark:**
The algorithm slightly deviates from the method outlined in [TR-02102-1]_
in that the interval used for the prime generation depends on the parity of ``bits``
and :math:`p` and :math:`q` are chosen to be congruent to :math:`3` modulo :math:`4`.
However, the interval is still sufficiently large and since about 25% of all pairs of odd primes satisfy the congruence condition,
it is not expected that this restriction affects the security of the resulting RSA keys.

**Conclusion:** The algorithm fulfills all main requirements listed in
[TR-02102-1]_. The minimum possible bit length of the modulus N should be
increased to the recommendation of 2000 bit.

.. _pubkey_key_generation/xmss:

XMSS with WOTS+
---------------

Botan implements the single tree version of the eXtended Merkle
Signature Scheme (XMSS) using Winternitz One Time Signatures+ (WOTS+) in

:srcref:`src/lib/pubkey/xmss/`. The implementation is based on RFC8391 [XMSS]_ and implements
the additional parameter sets and the adaptions to the key generation defined in
NIST's [SP800-208]_.
The list of supported algorithms and their parameters is depicted in
Table :ref:`Supported XMSS Signature algorithms <pubkey_key_generation/xmss/table>`.

.. _pubkey_key_generation/xmss/table:

.. table::  Supported XMSS Signature algorithms and their parameters (see Section 5.3 in [XMSS]_)

   +-------------------------+----+----+-----+----+--------------+
   |                         | Parameters         |              |
   | XMSS algorithm          +----+----+-----+----+ defined in   |
   |                         | n  | w  | len | h  |              |
   +=========================+====+====+=====+====+==============+
   | XMSS-SHA2_10_256        | 32 | 16 | 67  | 10 | [XMSS]_      |
   +-------------------------+----+----+-----+----+--------------+
   | XMSS-SHA2_16_256        | 32 | 16 | 67  | 16 | [XMSS]_      |
   +-------------------------+----+----+-----+----+--------------+
   | XMSS-SHA2_20_256        | 32 | 16 | 67  | 20 | [XMSS]_      |
   +-------------------------+----+----+-----+----+--------------+
   | XMSS-SHA2_10_192        | 24 | 16 | 51  | 10 | [SP800-208]_ |
   +-------------------------+----+----+-----+----+--------------+
   | XMSS-SHA2_16_192        | 24 | 16 | 51  | 16 | [SP800-208]_ |
   +-------------------------+----+----+-----+----+--------------+
   | XMSS-SHA2_20_192        | 24 | 16 | 51  | 20 | [SP800-208]_ |
   +-------------------------+----+----+-----+----+--------------+
   | XMSS-SHA2_10_512 [#x]_  | 64 | 16 | 131 | 10 | [XMSS]_      |
   +-------------------------+----+----+-----+----+--------------+
   | XMSS-SHA2_16_512 [#x]_  | 64 | 16 | 131 | 16 | [XMSS]_      |
   +-------------------------+----+----+-----+----+--------------+
   | XMSS-SHA2_20_512 [#x]_  | 64 | 16 | 131 | 20 | [XMSS]_      |
   +-------------------------+----+----+-----+----+--------------+
   | XMSS-SHAKE_10_256 [#x]_ | 32 | 16 | 67  | 10 | [XMSS]_      |
   +-------------------------+----+----+-----+----+--------------+
   | XMSS-SHAKE_16_256 [#x]_ | 32 | 16 | 67  | 16 | [XMSS]_      |
   +-------------------------+----+----+-----+----+--------------+
   | XMSS-SHAKE_20_256 [#x]_ | 32 | 16 | 67  | 20 | [XMSS]_      |
   +-------------------------+----+----+-----+----+--------------+
   | XMSS-SHAKE_10_512 [#x]_ | 64 | 16 | 131 | 10 | [XMSS]_      |
   +-------------------------+----+----+-----+----+--------------+
   | XMSS-SHAKE_16_512 [#x]_ | 64 | 16 | 131 | 16 | [XMSS]_      |
   +-------------------------+----+----+-----+----+--------------+
   | XMSS-SHAKE_20_512 [#x]_ | 64 | 16 | 131 | 20 | [XMSS]_      |
   +-------------------------+----+----+-----+----+--------------+
   | XMSS-SHAKE256_10_256    | 32 | 16 | 67  | 10 | [SP800-208]_ |
   +-------------------------+----+----+-----+----+--------------+
   | XMSS-SHAKE256_16_256    | 32 | 16 | 67  | 16 | [SP800-208]_ |
   +-------------------------+----+----+-----+----+--------------+
   | XMSS-SHAKE256_20_256    | 32 | 16 | 67  | 20 | [SP800-208]_ |
   +-------------------------+----+----+-----+----+--------------+
   | XMSS-SHAKE256_10_192    | 24 | 16 | 51  | 10 | [SP800-208]_ |
   +-------------------------+----+----+-----+----+--------------+
   | XMSS-SHAKE256_16_192    | 24 | 16 | 51  | 16 | [SP800-208]_ |
   +-------------------------+----+----+-----+----+--------------+
   | XMSS-SHAKE256_20_192    | 24 | 16 | 51  | 20 | [SP800-208]_ |
   +-------------------------+----+----+-----+----+--------------+

.. [#x] These parameter sets are explicitly not approved by NIST's [SP800-208]_.

XMSS and WOTS+ rely on the hash function address scheme (``ADRS``). This
scheme consists of 256 bits and stores OTS hash addresses and hash tree
addresses, see Section 2.5 in [XMSS]_. ``ADRS`` is implemented in
:srcref:`src/lib/pubkey/xmss/xmss_address.h` and offers the following setter methods.
The respective getter methods were left out for readability:

-  ``set_key_mask_mode(Key_Mode=0 / Mask_Mode=1, Mask_LSB_Mode=1,
   Mask_MSB_Mode=2)``
-  ``set_chain_address(i)``
-  ``set_hash_address(i)``
-  ``set_ots_address(i)``
-  ``set_ltree_address(i)``
-  ``set_type(OTS Hash Address / L-Tree Address / Hash Tree Address)``
-  ``set_tree_height(i)``
-  ``set_tree_index(i)``

XMSS and WOTS+ use a specific **base w** number representation. For
example, this representation turns a string ``X=0x1234`` into a byte array
``{1,2,3,4}=base_w(X, 16, 4)``. We refer to Section 2.6, Algorithm 1
[XMSS]_ for more details.

.. _pubkey_key_generation/wotsp:

WOTS+
~~~~~

WOTS+ uses a chaining function ``chain(X,i,s,ADRS,seed)`` to iteratively
execute ``s`` PRF calls on a given input string ``X``, the start index ``i``,
number of steps ``s``, combined with ``ADRS`` and a ``seed`` value. See
Algorithm 2 in [XMSS]_ for more details.

WOTS+ and in particular the ``chain`` function are implemented in
:srcref:`src/lib/pubkey/xmss/xmss_wots.cpp`.

Botan's ``XMSS_WOTS_PrivateKey`` encapsulate a single WOTS+ leaf node and
the associated key derivation from the ``private_seed`` and ``public_seed``.
Note that this key derivation follows the recommendation from NIST's [SP800-208]_
to avoid a multi-target attack vulnerability. This alternative derivation does not
affect the interoperability of Botan's XMSS signature verification with other implementations that do not
contain this countermeasure.

.. admonition:: WOTS+ leaf node key generation

   **Input:**

   - ``ADRS``: address of the leaf node key to be generated
   - ``oid``: XMSS WOTS+ parameters (``n``, ``w``, ``len``, ``PRF``)
   - ``private_seed``: private seed to derive WOTS+ private keys from
   - ``public_seed``: public seed

   **Output:**

   - ``sk`` and ``pk`` of the WOTS+ leaf node

   **Steps:**

   1. Derive the WOTS+ private key:

       - For each ``sk[i]`` with  ``i`` from ``0`` to ``len`` in the WOTS+
         private key set chain address to ``i`` in ``ADRS`` and generate
         ``sk[i]`` as: ``PRF_keygen(private_seed, public_seed | ADRS)``

   2. Derive the WOTS+ public key from the private key:

       - For each ``pk[i]`` with ``i`` from ``0`` to ``len`` set chain
         address to ``i`` in ``ADRS`` and generate ``pk[i]`` as:
         ``chain(sk[i], 0, w-1, ADRS, public_seed)``

   **Notes:**

   - All referenced methods above are implemented in the constructors of
     ``WOTS_Public_Key`` and ``WOTS_Private_Key`` in
     :srcref:`src/lib/pubkey/xmss/xmss_wots.cpp`.

XMSS
~~~~

XMSS functionality is implemented in :srcref:`src/lib/pubkey/xmss/xmss_privatekey.cpp`.

The algorithm for key generation relies on the method ``treeHash`` from
Algorithm 9 in [XMSS]_. The ``treeHash`` method takes as input secret key
``sk``, start index ``s``, target node height ``t``, and address ``ADRS``. The
algorithm uses the input parameters and the secret key ``sk`` stored in
the XMSS_PrivateKey object to return the root node of a given tree,
whose height is ``t``. The index s represents the index of the left most
leaf of the WOTS+ public key. Botan implements the function as described
in Algorithm 9.

Based on the ``treeHash`` function the key generation process follows
Algorithm 10 in [XMSS]_ and it works as follows:

.. admonition:: XMSS key generation

   **Input:**

   -  ``rng``: random number generator
   -  ``xmss_algo_id``: XMSS signature parameter identifier (``n``, ``w``, ``len``,
      ``PRF``), see Table :ref:`Supported XMSS Signature algorithms <pubkey_key_generation/xmss/table>`

   **Output:**

   -  ``XMSS_PrivateKey``: ``SK``, ``PK``

   **Steps:**

   1. Generate new ``public_seed``, ``private_seed`` and ``SK_PRF`` seed using ``rng``.
      Each seed has length ``n``.
   2. Initiate the index registry with ``idx=0``. This value references the
      first unused leaf index.
   3. Compute the ``root`` node value by walking through the entire XMSS tree
      using the ``treeHash`` function (Algorithm 9 in [XMSS]_). This derives all
      WOTS+ leaf nodes using the generation algorithm described above.

      ``root = treeHash(0, h, ADRS);``

   4. | ``SK = {idx, private_seed, SK_PRF, root, public_seed}``
      | ``PK = {OID, root, public_seed}``

   **Notes:**

   - The generation procedure is implemented in :srcref:`src/lib/pubkey/xmss/xmss_privatekey.cpp`
     in the ``XMSS_PrivateKey()`` constructor and ``XMSS_PrivateKey::tree_hash()``
     as well as ``XMSS_PrivateKey::tree_hash_subtree()``

**Remark:** Note that Botan does not store the whole XMSS keys in
memory. Only ``public_seed``, ``private_seed``, and ``SK_PRF`` are stored, and
are used to construct keys on demand. See also Section 4.1.11 in [XMSS]_.

.. _pubkey_key_generation/xmss/Remark_02:

**Remark:** XMSS is based on the repeated application of a hash function to
secret key material. In order to conduct a successful timing-based side
channel attack, an attacker needs to be able to calculate the hash
value's pre images by observing the timing behavior of the involved
processes. If such a side-channel exists in the implementation of the
hash function, an attacker can exploit it even in a single threaded
setting.

Specifically, in Botan's (multi-threaded) implementation of the XMSS hash tree
another (harmless) side channel may arise:

By observing the system load or the number of active threads, an
attacker can infer the location in the hash tree structure that the
currently running computations are working on. Depending on the
parameters, the key generation and the signature computation are running
in constant time on identical hardware if the hash function computations
run in constant time. Therefore, an attacker can infer the position in
the tree that the algorithm is currently working on even if only a
single thread is used.

.. _pubkey_key_generation/sphincsplus:

SPHINCS\ :sup:`+`
-----------------

Botan's SPHINCS\ :sup:`+` implementation is found in
:srcref:`src/lib/pubkey/sphincsplus/` and follows [SPX-R3]_. It supports the
parameter sets provided in Table 3 of [SPX-R3]_ for the SHA2 and SHAKE
instantiations of hash functions (note that currently, the instantiations with
Haraka are not supported). An overview is provided in Table :ref:`Supported
SPHINCS+ parameter sets <pubkey_key_generation/sphincsplus/params_table>`.

.. _pubkey_key_generation/sphincsplus/params_table:

.. table::  Supported SPHINCS+ parameter sets (see Table 3 of [SPX-R3]_). <hash> can either be ``sha2`` or ``shake``.

   +----------------------------------+-------------+-------------+-----------+-----------------+-----------+-----------+
   | Parameter Set                    |  :math:`n`  |  :math:`h`  | :math:`d` | :math:`log(t)`  | :math:`k` | :math:`w` |
   +==================================+=============+=============+===========+=================+===========+===========+
   | ``SphincsPlus-<hash>-128s-r3.1`` | 16          | 63          | 7         | 12              | 14        | 16        |
   +----------------------------------+-------------+-------------+-----------+-----------------+-----------+-----------+
   | ``SphincsPlus-<hash>-128f-r3.1`` | 16          | 66          | 22        |  6              | 33        | 16        |
   +----------------------------------+-------------+-------------+-----------+-----------------+-----------+-----------+
   | ``SphincsPlus-<hash>-192s-r3.1`` | 24          | 63          | 7         | 14              | 17        | 16        |
   +----------------------------------+-------------+-------------+-----------+-----------------+-----------+-----------+
   | ``SphincsPlus-<hash>-192f-r3.1`` | 24          | 66          | 22        |  8              | 33        | 16        |
   +----------------------------------+-------------+-------------+-----------+-----------------+-----------+-----------+
   | ``SphincsPlus-<hash>-256s-r3.1`` | 32          | 64          | 8         | 14              | 22        | 16        |
   +----------------------------------+-------------+-------------+-----------+-----------------+-----------+-----------+
   | ``SphincsPlus-<hash>-256f-r3.1`` | 32          | 68          | 17        |  9              | 35        | 16        |
   +----------------------------------+-------------+-------------+-----------+-----------------+-----------+-----------+

SPHINCS\ :sup:`+` key generation follows Section 6.2 of [SPX-R3]_ and is
implemented in :srcref:`src/lib/pubkey/sphincsplus/sphincspluscommon/sphincsplus.cpp`
within the the ``SphincsPlus_PrivateKey`` constructor. It works as follows:

.. admonition:: SPHINCS+ Key Generation

   **Input:**

   -  ``rng``: random number generator

   **Output:**

   -  ``SK``, ``PK``: private and public keys

   **Steps:**

   1. Generate new values ``secret_seed``, ``prf``, and ``public_seed`` using ``rng``.
   2. ``sphincs_root = xmss_gen_root(secret_seed)``
      (see :ref:`SPHINCS+ XMSS <signatures/sphincsplus/XMSS>`).
   3. | ``SK = {secret_seed, prf, public_seed, sphincs_root}``
      | ``PK = {public_seed, sphincs_root}``

   **Notes:**

   - The creation of a public key is conducted using the
     ``public_key`` method of the private key.


.. _pubkey_key_generation/dilithium:

Dilithium
---------

Botan's implementation of the CRYSTALS-Dilithium signature algorithm is based on the NIST round 3 specification [Dilithium-R3]_.
The parameter sets shown in Table :ref:`Supported Dilithium signature algorithms <pubkey_key_generation/dilithium/parameter_table>` are supported.

.. _pubkey_key_generation/dilithium/parameter_table:

.. table::  Supported Dilithium signature algorithms and their parameters (see Table 2 of [Dilithium-R3]_)

   +---------------------+------------------+------------------+------------------+
   | ``DilithiumMode``   | ``Dilithium4x4`` | ``Dilithium6x5`` | ``Dilithium8x7`` |
   +=====================+==================+==================+==================+
   | NIST Security Level |     2            |     3            |     5            |
   +---------------------+------------------+------------------+------------------+
   |         :math:`q`   |  8380417         |  8380417         |  8380417         |
   +---------------------+------------------+------------------+------------------+
   |         :math:`d`   |     13           |     13           |     13           |
   +---------------------+------------------+------------------+------------------+
   |      :math:`\tau`   |     39           |     49           |     60           |
   +---------------------+------------------+------------------+------------------+
   | challenge entropy   |    192           |    225           |    257           |
   +---------------------+------------------+------------------+------------------+
   | :math:`\gamma_1`    |  :math:`2^{17}`  |  :math:`2^{19}`  |  :math:`2^{19}`  |
   +---------------------+------------------+------------------+------------------+
   | :math:`\gamma_2`    |(q - 1)/88        |(q - 1)/32        |(q - 1)/32        |
   +---------------------+------------------+------------------+------------------+
   | :math:`(k, \ell)`   |   (4, 4)         |   (6, 5)         |   (8, 7)         |
   +---------------------+------------------+------------------+------------------+
   |     :math:`\eta`    |     2            |     4            |     2            |
   +---------------------+------------------+------------------+------------------+
   |    :math:`\beta`    |     78           |    196           |    120           |
   +---------------------+------------------+------------------+------------------+
   |    :math:`\omega`   |     80           |     55           |     75           |
   +---------------------+------------------+------------------+------------------+
   |     Repetitions     |    4.25          |    5.1           |    3.85          |
   +---------------------+------------------+------------------+------------------+

The Dilithium implementation is composed of several components.
An overview of the components is provided in Table :ref:`Dilithium components and file locations <pubkey_key_generation/dilithium/component_table>`.

.. _pubkey_key_generation/dilithium/component_table:

.. table::  Dilithium components and file locations.

   +-----------------------------------------------------------------------------------+--------------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | Component                                                                         | File                                                                                 | Purpose                                                                                                                                                                                |
   +===================================================================================+======================================================================================+========================================================================================================================================================================================+
   | :ref:`Modes <pubkey_key_generation/dilithium/modes>`                              | :srcref:`src/lib/pubkey/dilithium/dilithium_common/dilithium.h`                      | Provide parameters and primitives                                                                                                                                                      |
   +-----------------------------------------------------------------------------------+--------------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Constants and Symmetric Primitives <pubkey_key_generation/dilithium/modes>` | :srcref:`src/lib/pubkey/dilithium/dilithium_common/dilithium_symmetric_primitives.h` | Constants and primitives interface                                                                                                                                                     |
   +-----------------------------------------------------------------------------------+--------------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Modern Variant <pubkey_key_generation/dilithium/modes>`                     | :srcref:`src/lib/pubkey/dilithium/dilithium`                                         | "Modern" instantiations of primitives                                                                                                                                                  |
   +-----------------------------------------------------------------------------------+--------------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`AES Variant <pubkey_key_generation/dilithium/modes>`                        | :srcref:`src/lib/pubkey/dilithium/dilithium_aes`                                     | "AES" instantiations of primitives                                                                                                                                                     |
   +-----------------------------------------------------------------------------------+--------------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Polynomial Operations <pubkey_key_generation/dilithium/polynomials>`        | :srcref:`src/lib/pubkey/dilithium/dilithium_common/dilithium_polynomials.h`          | Polynomials and operations on them                                                                                                                                                     |
   +-----------------------------------------------------------------------------------+--------------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | Dilithium                                                                         | :srcref:`src/lib/pubkey/dilithium/dilithium_common/dilithium.h`                      | Dilithium :ref:`Keys <pubkey_key_generation/dilithium/keys>`, :ref:`Signature Creation <pubkey_signature/dilithium/sig>`, :ref:`Signature Validation <pubkey_signature/dilithium/val>` |
   +-----------------------------------------------------------------------------------+--------------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

.. _pubkey_key_generation/dilithium/modes:

**Modes, Constants and Symmetric Primitives**

Similar to CRYSTALS-Kyber, the different ways to instantiate Dilithium are realized as different modes (class ``DilithiumMode``; see Table :ref:`Supported Dilithium signature algorithms <pubkey_key_generation/dilithium/parameter_table>`).
A ``DilithiumMode`` provides the constants of the respective parameter set as ``DilithiumModeConstants``.
Also like Kyber, Dilithium additionally supports different instantiations of symmetric primitives via the class ``Dilithium_Symmetric_Primitives`` (see usage of SHAKE-128 vs. AES in Section 5.3 of [Dilithium-R3]_).
These are also provided by the mode and result in the "modern" and "AES" versions.
An "AES" version is identified via the ``_aes`` suffix in the mode string.

.. _pubkey_key_generation/dilithium/polynomials:

**Polynomial Operations**

``A*b`` of a polynomial matrix ``A`` and a polynomial vector ``b`` in the NTT domain is given via ``PolynomialVector::generate_polyvec_matrix_pointwise_montgomery`` and ``a*b`` of two polynomial vectors ``a`` and ``b`` is given via ``PolynomialVector::polyvec_pointwise_poly_montgomery``.
Matrices and vectors are transformed to the NTT representation prior to the operation.
To perform the multiplication ``2^d*a`` with the scalar ``2^d`` and the vector ``a``, the method ``PolynomialVector::polyvec_shiftl`` is used.

In addition to core polynomial operations, Dilithium relies on several supporting algorithms, see Section 2.3, Section 2.4, and the alterations of Section 5 of [Dilithium-R3]_.
Concretely, :math:`\mathsf{SampleInBall}` of [Dilithium-R3]_ is provided via ``Polynomial::poly_challenge``, :math:`\mathsf{ExpandA}` via ``PolynomialMatrix::generate_matrix``, :math:`\mathsf{ExpandS}` via ``PolynomialVector::fill_polyvec_uniform_eta`` (called to fill vectors of different lengths), and :math:`\mathsf{ExpandMask}` via ``PolynomialVector::polyvecl_uniform_gamma1``.
The function :math:`\mathsf{H}` is instantiated directly.

Furthermore, the algorithm :math:`\mathsf{Power2Round}_q` of [Dilithium-R3]_ corresponds to the functions ``Polynomial::power2round`` and ``Polynomial::fill_polys_power2round``.
:math:`\mathsf{MakeHint}_q` and :math:`\mathsf{UseHint}_q` of [Dilithium-R3]_ are realized by ``Polynomial::make_hint``\/\ ``Polynomial::generate_hint_polynomial`` and ``Polynomial::use_hint``, respectively.
:math:`\mathsf{Decompose}_q` is given via ``Polynomial::decompose`` and ``Polynomial::poly_decompose``.
During the signature operations, the decomposition functions are used directly instead of using the :math:`\mathsf{HighBits}_q` \/ :math:`\mathsf{LowBits}_q` paradigm.
Versions with element-wise applications on polynomial vectors are given as well.

Finally, Botan supplies packing operations (Section 5.2, [Dilithium-R3]) and the function ``PolynomialVector::polyvec_chknorm``, which realizes a check if the :math:`\lVert \cdot \rVert_\infty` norm of a given polynomial vector surpasses a provided bound.

.. _pubkey_key_generation/dilithium/keys:

**Keys**

In Botan, Dilithium's keys are represented as ``Dilithium_PublicKey`` for public keys ``pk`` and as ``Dilithium_PrivateKey`` for secret keys ``sk``.
Public keys contain the matrix seed ``rho`` and the public value ``t1``.
Also, when creating a ``pk`` object the value  ``tr = CRH(rho || t1)`` is precomputed from the public key values ``rho`` and ``t1``, which is used by the verification algorithm.
We therefore write ``pk = (rho, t1)`` during key generation and ``pk = (rho, t1, tr)`` during verification.
The ``sk`` object contains the values ``rho`` and ``tr`` of the ``pk``.
It also contains the seed ``key``, the vectors ``s1`` and ``s2``, and the value ``t0``. We write ``sk = (rho, tr, key, s1, s2, t0)``.

The keys use a helper function ``calculate_t0_and_t1`` to compute :math:`(\mathbf{t_1},\mathbf{t_0})` based on the public key seed ``rho`` and private vectors ``s1, s2``, i.e., realizing L. 3, L.5, and L. 6, Fig. 4, [Dilithium-R3]_.
Furthermore, encoding and decoding of keys and signatures are provided via the key classes.

The Dilithium key generation process follows :math:`\mathsf{Gen}` of Figure 4 of [Dilithium-R3]_ and works as follows:

.. admonition:: Dilithium_PrivateKey::Dilithium_PrivateKey()

   **Input:**

   -  ``rng``: random number generator
   -  ``m``: Dilithium mode providing parameters and symmetric functions

   **Output:**

   -  ``sk``: secret key
   -  ``pk``: public key

   **Steps:**

   1. Generate random seed ``seedbuf`` using ``rng`` (L. 1, Fig. 4, [Dilithium-R3]_)
   2. ``(rho || rhoprime || key) = H(seedbuf)`` (L. 2, Fig. 4, [Dilithium-R3]_)
   3. ``matrix = PolynomialMatrix::generate_matrix(rho, m)`` (L. 3, Fig. 4, [Dilithium-R3]_)
   4. Use ``PolynomialVector::fill_polyvec_uniform_eta`` to fill ``s1`` and ``s2`` (L. 4, Fig. 4, [Dilithium-R3]_)
   5. ``(t0, t1) = calculate_t0_and_t1(m, rho, s1, s2)`` (L. 5-6, Fig. 4, [Dilithium-R3]_)
   6. ``pk = (rho, t1)`` (:math:`pk` in L. 8, Fig. 4, [Dilithium-R3]_)
   7. ``tr = H(rho || t1)`` (L. 7, Fig. 4, [Dilithium-R3]_)
   8. ``sk = (rho, tr, key, s1, s2, t0)`` (:math:`sk` in L. 8, Fig. 4, [Dilithium-R3]_)

   **Notes:**

   - ``matrix`` is already generated in NTT representation.
   - The calculation of ``calculate_t0_and_t1`` includes the computation of ``matrix*s1`` in the NTT domain.


.. _pubkey_key_generation/kyber:

Kyber
-----

Botan implements the CRYSTALS-Kyber KEM in
``src/lib/pubkey/kyber/``. The implementation is based on the NIST round 3 specification [Kyber-R3]_.
The list of supported algorithms and their parameters is depicted in
Table :ref:`Supported Kyber parameter sets <pubkey_key_generation/kyber/table_params>`.
All possible modes are represented by the class ``KyberMode`` found in ``src/lib/pubkey/kyber/kyber_common``.
The ``_90s`` suffix denotes different symmetric functions for Kyber's \"90s mode\", which uses SHA2 and AES instead of SHA3 and SHAKE as symmetric primitives.
The abstract adapter class ``Kyber_Symmetric_Primitives`` is the interface for Kyber's five symmetric primitives, which are instantiated either as a ``Kyber_Modern_Symmetric_Primitives`` object (in ``src/lib/pubkey/kyber/kyber``) for modern Kyber
or as a ``Kyber_90s_Symmetric_Primitives`` one (in ``src/lib/pubkey/kyber/kyber_90s``) for the 90s variant (see Table :ref:`Kyber's symmetric primitives <pubkey_key_generation/kyber/table_sym_primitives>`).
For each mode, the ``KyberConstants`` class contains the corresponding set of parameters and symmetric functions (``Kyber_Symmetric_Primitives``).

.. _pubkey_key_generation/kyber/table_params:

.. table::  Supported Kyber parameter sets (see Section 1.4 in [Kyber-R3]_)

   +-------------------+-----+---+------+------+------+-----+-----+
   |  Mode             | N   | k | Q    | eta1 | eta2 | d_u | d_v |
   +===================+=====+===+======+======+======+=====+=====+
   | Kyber512          | 256 | 2 | 3329 | 3    | 2    | 10  | 4   |
   +-------------------+-----+---+------+------+------+-----+-----+
   | Kyber768          | 256 | 3 | 3329 | 2    | 2    | 10  | 4   |
   +-------------------+-----+---+------+------+------+-----+-----+
   | Kyber1024         | 256 | 4 | 3329 | 2    | 2    | 11  | 5   |
   +-------------------+-----+---+------+------+------+-----+-----+

.. _pubkey_key_generation/kyber/table_sym_primitives:

.. table:: Kyber's symmetric primitives (see Section 1.4 in [Kyber-R3]_)

   +-------------------+--------------+----------+-----------+--------------+------------+
   |  Variant          | XOF          | H        | G         | PRF          | KDF        |
   +===================+==============+==========+===========+==============+============+
   | Kyber             | SHAKE-128    | SHA3-256 | SHA3-512  | SHAKE-256    | SHAKE-256  |
   +-------------------+--------------+----------+-----------+--------------+------------+
   | Kyber 90s         | AES-256-CTR  | SHA-256  | SHA512    | AES-256-CTR  | SHA-256    |
   +-------------------+--------------+----------+-----------+--------------+------------+

Kyber itself is implemented in ``src/lib/pubkey/kyber/kyber_common/kyber.cpp``.
Basic representations and operations on polynomials, polynomial vectors, and polynomial matrices are given via the ``Polynomial``, ``PolynomialVector``, and ``PolynomialMatrix`` classes, respectively.
``Polynomial`` and ``PolynomialVector`` support member functions ``.ntt()`` and ``.invntt()`` for the number-theoretic transform (NTT; see more details in Section 1.1 of [Kyber-R3]_) and fast multiplication in the NTT domain.
Multiplication of two polynomial vectors in NTT domain ``a*b`` is given via the function ``PolynomialVector::pointwise_acc_montgomery`` using Montgomery reduction.
Note that the inverse NTT is called ``.invntt_tomont()`` in Botan's implementation as it directly multiplies by the Montgomery factor; however, for simplicity, we write ``.invntt()`` in this documentation.

Additionally, ``PolynomialMatrix`` has a member function ``generate(seed, transposed, mode)``, which generates a (possibly transposed) ``k``:math:`\times`\ ``k`` matrix ``a`` from the ``seed`` given a ``mode``.
The matrix is already generated in the NTT domain via rejection sampling with ``XOF`` (using the function ``Polynomial::sample_rej_uniform(XOF)`` that corresponds to **Algorithm 1** of [Kyber-R3]_).

**Algorithm 2** of [Kyber-R3]_ is implemented via the member function ``Polynomial::getnoise_cbd2`` for the case ``eta1=2`` (and a respective version for ``eta1=3``). It deterministically samples noise from a centered binomial distribution.

Encoding/decoding of polynomials (**Algorithm 3** of [Kyber-R3]_) is realized via the ``Polynomial::to_bytes()``/ ``Polynomial::from_bytes()`` functions.

Based on these functions the key generation process follows **Algorithms 4 and 7** of [Kyber-R3]_ and works as follows:

.. admonition:: Kyber_PrivateKey::Kyber_PrivateKey()

   **Input:**

   -  ``rng``: random number generator
   -  ``m``: Kyber mode providing (``N``, ``k``, ``Q``, ``XOF``, ``H``, ``G``, ``PRF``, ``KDF``), see Table :ref:`Supported Kyber parameter sets <pubkey_key_generation/kyber/table_params>` and Table :ref:`Kyber's symmetric primitives <pubkey_key_generation/kyber/table_sym_primitives>`

   **Output:**

   -  ``sk``: secret key
   -  ``pk``: public key

   **Steps:**

   1. ``(seed1 || seed2) = G(d)`` where d is generated using ``rng`` and each seed has the same length (L. 1-2, Alg. 4 [Kyber-R3]_)
   2. ``a = PolynomialMatrix::generate(seed1, false, m)`` (L. 4-8, Alg. 4 [Kyber-R3]_)
   3. ``s = PolynomialVector::getnoise_eta1(seed2, 0, m)`` (performs ``k`` invocations of ``Polynomial::getnoise_eta1``, one for each component of ``s``; L. 9-12, Alg. 4 [Kyber-R3]_)
   4. ``e = PolynomialVector::getnoise_eta1(seed2, k, m)`` (performs ``k`` invocations of ``Polynomial::getnoise_eta1``, one for each component of ``e``; L. 13-16, Alg. 4 [Kyber-R3]_)
   5. ``s.ntt()`` and ``e.ntt()`` (L. 17-18, Alg. 4 [Kyber-R3]_)
   6. ``pk = (a*s + e, seed1)`` and ``sk = (s, pk, H(pk), z)`` where ``z`` is freshly generated with ``rng`` (L. 19-22, Alg. 4 [Kyber-R3]_ and L.1, 3, Alg. 7 [Kyber-R3]_)

   **Notes:**

   - The member function ``Polynomial::getnoise_eta1(seed, nonce, mode)`` uses ``PRF`` on the seed with incremented nonce values to call ``Polynomial::getnoise_cbd2`` or ``Polynomial::getnoise_cbd3`` depending on ``eta1``.
   - Serialization to bytes of the keys (:math:`\mathsf{Encode}` in L.20, 21, Alg. 4 [Kyber-R3]_) is performed via the constructor of the internal classes for public and secret keys (``Kyber_PublicKeyInternal`` and ``Kyber_PrivateKeyInternal``) by calling ``Polynomial::to_bytes()``.
