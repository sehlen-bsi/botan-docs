.. _prim:

Prime Number Generation
=======================

Asymmetric encryption, key exchange or signature algorithms like RSA and
Diffie-Hellman require long random primes. Botan offers three prime
number generation functions. Directive [TR-02102-1]_ recommends the usage
of the probabilistic Miller-Rabin primality test, which is used in all
functions.

The following helper functions are used during prime number generation:

1. ``miller_rabin_test_iterations(size_t n_bits, size_t prob, bool random)``
2. ``is_prime(const BigInt& n, RandomNumberGenerator& rng, size_t prob = 64, bool is_random = false)``

The function ``miller_rabin_test_iterations()`` is implemented in
:srcref:`src/lib/math/numbertheory/primality.cpp` and operates as follows:

.. admonition:: ``miller_rabin_test_iterations()``

   **Input:**

   -  ``bits``: Bit length of the prime
   -  ``prob``: Upper bound for the chance of a composite return value
      (as :math:`\sfrac{1}{2^{prob}}`)
   -  ``random``: Whether it is ensured that the number was created at
      random and not maliciously constructed

   **Output:**

   -  The number of required Miller-Rabin iterations required to ensure
      primality

   **Steps:**

   1. Compute the worst case ``base`` with :math:`{({\mathit{prob} + 2})}/2`.
   2. If ``random`` is false return ``base``.
   3. If ``prob`` is 128 or lower

      -  return 4 if ``bits`` is at least 1536
      -  return 6 if ``bits`` is at least 1024
      -  return 12 if ``bits`` is at least 512
      -  return 29 if ``bits`` is at least 256

   4. Otherwise return ``base``.

The function ``is_prime()`` is implemented in
:srcref:`src/lib/math/numbertheory/numthry.cpp` and operates as follows:

.. admonition:: ``is_prime()``

   **Input:**

   -  ``n``: The number to test for primality
   -  ``rng``: Random number generator
   -  ``prob``: Upper bound for the chance of a composite return value
      (as :math:`\sfrac{1}{2^{prob}}`).
      This influences the number of Miller-Rabin iterations performed in
      primality tests.
   -  ``is_random``: Whether it is ensured that the number was created at
      random and not maliciously constructed

   **Output:**

   -  True if all primality and auxiliary tests passed, otherwise false.

   **Steps:**

   1. If ``n`` is 2 return true.
   2. If ``n`` is smaller than 2 or even return false.
   3. If ``n`` is smaller than 65536 search for ``n`` in the table of
      precomputed primes. If ``n`` is found return true, if ``n`` is not found
      return false.
   4. If ``rng`` is not seeded, perform the Bailie-PSW primality test (function
      ``is_bailie_psw_probable_prime()`` in
      :srcref:`src/lib/math/numbertheory/primality.cpp`), which is a combination of
      Miller-Rabin with base 2 and a Lucas test.
      Otherwise:

      -  Conducts Miller-Rabin primality test (function
         ``is_miller_rabin_probable_prime()`` in
         :srcref:`src/lib/math/numbertheory/primality.cpp`). The number of
         iterations is computed with ``miller_rabin_test_iterations()``. If
         the test fails returns false.
      -  If the prime was not generated randomly
         conducts a Lucas test (function ``is_lucas_probable_prime()`` in
         :srcref:`src/lib/math/numbertheory/primality.cpp`) and returns the result.

The function ``passes_miller_rabin_test()`` implements the actual Miller-Rabin test
in :srcref:`src/lib/math/numbertheory/primality.cpp` for a single ``a``.
``is_miller_rabin_probable_prime()`` runs this function for a specified number of
iterations with randomly generated ``a``.

.. admonition:: ``passes_miller_rabin_test()``

   **Input:**

   - ``n``: the number to be tested for primality
   - ``a``: the random base generated by ``is_miller_rabin_probable_prime()``
     with :math:`2 < a < n`
   - ``mod_n``: the modular reducer for ``n`` (used internally for calculations modulo ``n``)
   - ``monty_n``: montgomery parameters (used internally for Montgomery exponentiation)

   **Output:**

   - True if Miller-Rabin test passed, otherwise false

   **Steps:**

   1. If ``n`` is even or lower than 3: return ``false``.
   2. Calculate :math:`n_{-1} = n - 1`
   3. Devide :math:`n_{-1}` by two as often a possible:

      1. Get the number of least significant bits in :math:`n_{-1}` that are zero as: ``s``
      2. Devide :math:`n_{-1}` by :math:`2^s`: :math:`n_{base} = n_{-1} >> s`

   4. Calculate :math:`y_0 = (a^{n_{base}} \bmod n)` using constant-time Montgomery exponentiation
      and return ``true`` iff the result is :math:`1` or :math:`n_{-1}`
   5. Square :math:`y_{i+1} = ({y_i}^2 \bmod n)` for :math:`s-1` times and return ``false`` if
      :math:`y_i` is ever 1, ``true`` if and only if it ever becomes :math:`n_{-1}` and ``false`` otherwise.

Thes function ``is_lucas_probable_prime()`` implements the Lucas primality test
for a given number ``C`` in :srcref:`src/lib/math/numbertheory/primality.cpp`. The
implementation follows the specification in [FIPS-186-4]_ C.3.3.

.. admonition:: ``is_lucas_probable_prime()``

   **Input:**

   - ``C``: the number to be tested for primality
   - ``mod_C``: the modular reducer for ``C`` (used internally for calculations modulo ``C``)

   **Output:**

   - True if Lucas test passed, false otherwise

   **Steps:**

   1. Check :math:`C` to be equal to one of the 6 smallest primes, returning ``true`` if a match is found
   2. Ensure that :math:`C` is larger than 1 and odd, and return ``false`` otherwise
   3. For each :math:`D_i` proceed as follows until either ``false`` is returned or a suitable :math:`D` is found:

      - Calculate the Jacobi symbol :math:`j = (\frac{D_i}{C})`, and

         - If :math:`j = 0`, return ``false``
         - If :math:`j = -1`, set :math:`D = D_i` and continue with Step 4
         - If :math:`D_i = 17` and :math:`C` is not a perfect square, return false

   4. Set:

      - :math:`K = C + 1`
      - :math:`U = 1`
      - :math:`V = 1`

   5. For each bit :math:`K_i` in :math:`C` in order of decreasing significance
      (but excluding the most significant bit):

      1. :math:`U_{temp} = U * V \bmod C`
      2. :math:`V_{temp} = \frac{V^2 + D * U^2}{2} \bmod C`
      3. :math:`U = U_{temp}, V = V_{temp}`
      4. :math:`U_2 = \frac{U_{temp} + V_{temp}}{2} \bmod C`
      5. :math:`V_2 = \frac{V_{temp} + D * U_{temp}}{2} \bmod C`
      6. If `K_i` is set, overwrite: :math:`U = U_2, V = V_2`

   6. Return true iff :math:`U = 0`

   **Note:**

      - The loop over the :math:`K_i` bits of :math:`K` in step 5 is implemented
        as a constant-time algorithm
      - Divisions by :math:`2` in step 5 are implemented as right bitshifts. If
        the dividend is an odd number, :math:`C` is first added to it. After the
        division, the result is reduced by (:math:`\bmod C`).

The functions for generating the prime numbers are part of
:srcref:`src/lib/math/numbertheory/make_prm.cpp`.

1. ``random_prime(RandomNumberGenerator& rng, size_t bits, const BigInt& coprime, size_t equiv, size_t modulo, size_t prob)``
2. ``random_safe_prime(RandomNumberGenerator& rng, size_t bits)``
3. ``generate_rsa_prime(RandomNumberGenerator& keygen_rng, RandomNumberGenerator& prime_test_rng, size_t bits, const BigInt& coprime size_t prob = 128)``

The function ``random_prime()`` operates as follows:

.. admonition:: ``random_prime()``

   **Input:**

   -  ``bits``: Bit length of the prime
   -  ``rng``: Random number generator
   -  ``coprime``: Number to which ``p-1`` shall be coprime to. If this
      parameter is not given, it defaults to 0 (no coprimality requested).
   -  ``equiv, modulo``: Number the prime shall be equivalent to (if not
      given, defaults to 1), using modulus ``modulo`` (if not given, defaults
      to 2).
   -  ``prob``: Upper bound for the chance of a composite return value
      (as :math:`\sfrac{1}{2^{prob}}`).
      This influences the number of Miller-Rabin iterations performed in
      primality tests.

   **Output:**

   -  ``p``: prime with a bit-length of ``bits`` sampled from the random number
      generator passed as ``rng``, where ``p-1`` is coprime to ``coprime`` and
      ``p`` is congruent to ``equiv`` modulo ``modulo``.

   **Steps:**

   1. Preliminary parameter requirement checks are conducted. The algorithm
      requires a positive ``coprime`` that has less bits than ``bits``. It is
      also checked that ``coprime`` is odd or zero. The ``modulo`` must be
      between zero and 100000 [#prime_coprime_limit]_, and the ``equiv`` modulo
      the ``modulo`` must also not be zero.
      Furthermore, the algorithm terminates if a length of 1 is passed, as
      no primes with that bit-length exist.

      If ``bits`` is 16 or smaller, ``equiv`` must be 1, ``modulo`` must be 2 and
      ``coprime`` must be 0.

   2. For lengths up to 4 bits only 2 different primes exist for each
      length. In this case, the algorithm samples one byte from the passed
      random number generator and returns one of 2 possible primes based on
      the parity of the sampled random byte.

      -  2 bit length: 2,3
      -  3 bit length: 5,7
      -  4 bit length: 11,13

   3. For lengths between 5 and 16 a random 4 byte value b is generated. A
      prime is then chosen from a precomputed table with the first 6541
      primes (without 2) by using b modulo 6541 as an index. If the chosen
      prime is too big, this step is repeated. It should be noted that this
      choosing of a prime is slightly biased.

   4. The algorithm retrieves a random number candidate ``p`` of the passed
      length from the specified random number generator. Subsequently the 2
      highest [#random_prime_2_msbs]_ and the lowest bit are set to 1. Therefore, each candidate is odd
      and the multiplication of 2 candidates with the same bit length
      results in a doubling of the bit length. This is especially helpful
      when generating an RSA key pair.

   5. The function ensures that the candidate ``p`` is equivalent to ``equiv``
      modulo ``modulo``, by adding
      :math:`{({\mathit{modulo} - ( p \bmod \mathit{modulo})})} + \mathit{equiv}`
      to it. Note that ``equiv`` defaults to 1 and ``modulo`` to 2. In that
      case the condition is always met as the candidate is odd.

   6. To eliminate non-prime candidates, three primality and two additional
      tests are conducted consecutively. If the candidate fails one of the
      tests, it is incremented by ``modulo`` to preserve the equivalence
      modulo ``modulo`` and tested again. Note that the candidate is
      incremented by ``modulo`` a single time prior to the first test. Thus,
      the sampled candidate ``p`` itself is never checked. If a candidate
      fails 32*1024 times, go to Step 4.

      -  Check if ``p`` is even or divisible by the first
         :math:`\lfloor\mathit{bits}\rfloor`
         of 6541 included precomputed primes :math:`q_{i}`
         (without 2). Therefore, the algorithm checks if the equation
         :math:`p \bmod{q_{i} = 0}`
         applies for one of the primes :math:`q_{i}`
         . If that is the case, the candidate is composite and thus not
         prime.
      -  Check for the first :math:`\lfloor bits \rfloor` of 6541 included
         precomputed primes :math:`q_i` (without
         2) if the equation :math:`p\bmod{q_i}=(q_i-1)/2` holds for one
         of the primes :math:`q_i`. If that is the
         case, :math:`2*p+1` is composite and thus not prime, which means ``p``
         is not a Sophie Germain prime. [#random_prime_sophie_germain]_
      -  If ``coprime`` is bigger than one, do a single Miller-Rabin
         iteration (for performance reasons) before checking if
         :math:`\mathit{\gcd}{{({{p - 1},\mathit{coprime}})} = 1}`.
         As ``coprime`` defaults to 0, this condition is always fulfilled
         if ``coprime`` is not passed.
      -  Conducts Miller-Rabin primality test (function
         ``is_miller_rabin_probable_prime()`` in
         :srcref:`src/lib/math/numbertheory/primality.cpp`). The number of
         iterations is computed based on the ``prob`` parameter and ``bits`` by
         calling the ``miller_rabin_test_iterations()`` function for random
         numbers.
      -  If ``prob>32``, it conducts an additional Lucas test
         (function ``is_lucas_probable_prime()`` in
         :srcref:`src/lib/math/numbertheory/primality.cpp`) as recommended by
         Albrecht et al. [AMPS18]_.

.. [#prime_coprime_limit]
   This is an arbitrary limit to avoid integer overflows during sieving. See
   also `bfb2767 <https://github.com/randombit/botan/commit/bfb27678f339cc04118ac3ccc94f7f8ec0d1367f>`_.

.. [#random_prime_2_msbs]
   Setting the two highest bits in a random prime ensures that multiplying two
   such primes always results in a prime that has exactly the expected bit length.

.. [#random_prime_sophie_germain]
   ``random_prime()`` is used to generate primes suitable for discrete logarithm
   parameters

The function ``random_safe_prime()`` generates a safe prime:

.. _prim/random_safe_prime:

.. admonition:: ``random_safe_prime()``

   **Input:**

   -  ``bits``: bit length of the prime
   -  ``rng``: random number generator

   **Output:**

   -  ``p``: safeprime of form :math:`p=2*q+1` (``q`` is prime) with ``bits`` length sampled from the random
      number generator ``rng``.

   **Steps:**

   1. Call ``random_prime()`` to sample a prime ``q`` of length :math:`bits-1`. The probability
      is set to 128
      (i.e chance of a composite return value is at most :math:`\sfrac{1}{2^{128}}`).
   2. Compute candidate ``p`` as :math:`{q \ast 2} + 1`
   3. Check ``p`` with ``is_prime()`` for random numbers with probability set
      to 128 and random set to true. If the candidate fails the test, go
      to step 1.

The function ``generate_rsa_prime()`` operates as follows:

.. admonition:: ``generate_rsa_prime()``

   **Input:**

   -  ``bits``: Bit length of the prime
   -  ``keygen_rng``: Random number generator used to generate the prime
   -  ``prime_test_rng``: Random number generator used to test primality
   -  ``coprime``: Number to which ``p-1`` shall be coprime to.
   -  ``prob``: Upper bound for the chance of a composite return value
      (as :math:`\sfrac{1}{2^{prob}}`).
      Influences the number of Miller-Rabin iterations performed in
      primality tests.

   **Output:**

   -  ``p``: prime of ``bits`` length sampled from the random number generator
      passed with ``keygen_rng`` , where ``p-1`` is coprime to ``coprime``.

   **Steps:**

   1. Preliminary parameter requirement checks are conducted. The algorithm
      only generates primes with a ``bits`` length of at least 512. It
      requires an odd ``coprime`` that is bigger than 1 and has a bits length
      of at most 64.

   2. The algorithm retrieves a random number candidate ``p`` of the passed
      length from the specified random number generator ``keygen_rng``.
      Subsequently the two most significant and the two least significant bits are set. Therefore,
      each candidate is odd and the multiplication of two candidates with the
      same bit length results in a doubling of the bit length.
      Also each candidate is therefore always equal to :math:`3\bmod{4}`,
      meaning the inversion modulo ``phi(n)`` is always of the form ``2*o`` with ``o`` odd.
      This is especially helpful when generating an RSA key pair.

   3. To eliminate non-prime candidates, two primality and one additional
      test are conducted consecutively. If the candidate fails one of the
      tests, it is incremented by 4 and tested again. Note that the
      candidate is incremented by 4 a single time prior to the first test.
      Thus, the sampled candidate ``p`` itself is never checked. If a
      candidate fails 32*1024 times, go to step 2.

      -  Checks if ``p`` is even or divisible by the first
         :math:`\lfloor\mathit{bits}\rfloor`
         of 6541 included precomputed primes :math:`q_{i}`
         (without 2). Therefore, the algorithm checks if the equation
         :math:`p\bmod{q_{i} = 0}`
         holds for one of the primes :math:`q_{i}`
         . If that is the case, the candidate is composite and thus not
         prime.
      -  Do a single Miller-Rabin iteration (for performance reasons)
         before checking if the equation
         :math:`\mathit{\gcd}{{({{p - 1},\mathit{coprime}})} = 1}`
         holds. This measure very likely aims at preventing cycle
         attacks on RSA (which are not practical when long RSA primes are
         used) by limiting the number of fixpoints :math:`m^e=m\bmod{N}`, when passing the RSA
         exponent ``e`` as ``coprime``.
      -  Conducts Miller-Rabin primality test (function
         ``is_miller_rabin_probable_prime()`` in
         :srcref:`src/lib/math/numbertheory/primality.cpp`). The number of
         iterations is computed based on the ``prob`` and ``bits`` parameter by
         calling the ``miller_rabin_test_iterations()`` function for random
         numbers.

**Remark:** The second highest bit is set in step 4 of the
``random_prime()`` algorithm and step 2 of the ``generate_rsa_prime()``
algorithm. This reduces the complexity of guessing the generated prime
by 50%. However, this is a standard procedure by generating prime
numbers and does not influence the security if proper key sizes are
used.

**Conclusion:** The prime number generation algorithms ``random_prime()``
and ``generate_rsa_prime()``, implemented in Botan with a default
probability of 128, comply with the recommendations in [TR-02102-1]_ for
the average case. If the requested probability is higher than 128 the
algorithm performs more than 50 iterations of the Miller-Rabin primality
test, which means the generated primes are suitable for usage in
long-term keys. As the default probability for generating keys is only
128 in Botan, it is required to call the corresponding ``check_key()``
functions described in section :ref:`pubkey_key_generation/main` with the ``strong``
parameter set to true on keys that are intended for long-term usage.
