.. _pubkey/ecc:

Elliptic Curve Cryptography
===========================

Elliptic Curve Groups
---------------------

Botan implements the elliptic curve standard [ISO-15946-1]_ for elliptic curves
over :math:`\mathbb{F}_p`. The standard additionally defines curves over
:math:`\mathbb{F}_{2^m}` and :math:`\mathbb{F}_{3^m}` that are not implemented.
See :srcref:`src/build-data/ec_groups.txt` for a list of supported curves and
their parameters. All curves recommended in [TR-02102-1]_ are included.

In order to use any elliptic curve algorithm, it is required that both
participating parties agree on a domain, which consists of an elliptic
curve, a base point of the curve, the order of the base point and the cofactor.

.. table:: Elliptic Curve Group Parameters

   +--------------------------------------------------+---------------------------------------------------------+
   | Parameter                                        | Description                                             |
   +==================================================+=========================================================+
   | :math:`p`                                        | the prime of the underlying field :math:`\mathbb{F}_p`  |
   +--------------------------------------------------+---------------------------------------------------------+
   | :math:`a, b \in \mathbb{F}_p`                    | curve coefficients in short Weierstrass form            |
   +--------------------------------------------------+---------------------------------------------------------+
   | :math:`E_{a,b}: y^2 = x^3 + a \cdot x + b`       | the curve equation                                      |
   +--------------------------------------------------+---------------------------------------------------------+
   | :math:`G_{x,y}` on :math:`E_{a,b}(\mathbb{F}_p)` | the base point of the curve :math:`E_{a,b}`             |
   +--------------------------------------------------+---------------------------------------------------------+
   | :math:`n = ord(G_{x,y})`                         | the order of the base point :math:`G_{x,y}`             |
   +--------------------------------------------------+---------------------------------------------------------+
   | :math:`h = \#E_{a,b}(\mathbb{F}_p)/n`            | the cofactor of the curve (always :math:`1` in Botan)   |
   +--------------------------------------------------+---------------------------------------------------------+

For the most common named curves [#supported_curves]_, Botan provides optimized
implementations in its internal :srcref:`"pcurves" library
<src/lib/math/pcurves>`. Those utilize optimizations that leverage
curve-specific mathematical features for efficient modular reduction and field
inversions where possible.

For less commonly used or user-defined curves, a legacy implementation is
available in :srcref:`src/lib/pubkey/ec_group/`. Since Botan 3.7.1, this
implementation is deprecated.

Note that the detailed algorithm descriptions in the rest of this chapter always
refer to the optimized "pcurves" implementation. The previous implementation that
is used for custom curve parameters was the basis for previous revisions of this
document and was not changed significantly.

User-defined elliptic curve parameters can be imported at run time. However, it
is the application developer's responsibility to ensure that such custom curves
are trustworthy and cryptographically strong. Botan *does not* contain means to
ensure that automatically. It does however pose restrictions on the custom curve
parameters:

 - The modulus :math:`p` is prime and must be at least 192 bits (128 bits is
   allowed, but deprecated) and at most 512 bits. The bit length must be a
   multiple of 32 bits.

 - As an extension of the above restriction, the prime :math:`p` can also be exactly
   the 521-bit Mersenne prime (:math:`2^{521}-1`) or exactly the 239-bit prime used in
   X9.62 239-bit groups (:math:`2^{239} - 2^{143} - 2^{95} + 2^{47} - 1`).

 - The prime :math:`p` must be congruent to :math:`3 \bmod 4` to allow the efficient
   calculation of square roots.

 - The group order :math:`n` must have the same bit length as the prime :math:`p`
   and must itself be prime.

 - :math:`(4a^3 + 27b^2) \bmod p \neq 0` must hold.

 - The cofactor of the group must be :math:`h = 1`.

These restrictions are compatible with the main recommendations from [ReqEC]_
and checked during the construction of any custom `EC_Group` (see
:srcref:`[src/lib/pubkey/ec_group]/ec_group.cpp:414|EC_Group`). Previous
versions of the library had more liberal restrictions on the custom group
parameters, but those are now deprecated.

.. [#supported_curves]
   Botan's :srcref:`src/lib/math/pcurves/` directory contains a subdirectory for
   each supported curve.

Essential Elliptic Curve Algorithms and Structures
--------------------------------------------------

Public Data Structures
^^^^^^^^^^^^^^^^^^^^^^

These classes may be used for low-level access to elliptic curve operations by
applications that wish to implement their custom elliptic curve protocols. Note
that, with the exception of ``EC_Group``, the API of those classes is public but
not considered stable.

.. table:: Public Elliptic Curve Data Structures
   :widths: 30 70

   +----------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------+
   | Type/Location                                            | Purpose                                                                                                             |
   +==========================================================+=====================================================================================================================+
   | ``EC_Group``                                             |                                                                                                                     |
   | (:srcref:`code <[src/lib/pubkey/ec_group]/ec_group.h>`)  | An instance of elliptic curve group parameters specifying a group domain.                                           |
   +----------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------+
   | ``EC_Scalar``                                            |                                                                                                                     |
   | (:srcref:`code <[src/lib/pubkey/ec_group]/ec_scalar.h>`) | An arbitrary precision integer in the context of an ``EC_Group``, i.e., modulo the group's prime order ``n``.       |
   +----------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------+
   | ``EC_AffinePoint``                                       |                                                                                                                     |
   | (:srcref:`code <[src/lib/pubkey/ec_group]/ec_apoint.h>`) | An affine curve point in the context of an ``EC_Group``. Ensures that the contained point is always "on the curve". |
   +----------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------+

Private Data Structures
^^^^^^^^^^^^^^^^^^^^^^^

This is a non-exhaustive list of data structures and types used internally. These
are not accessible by an application using the library. For further details, please
consult the implementations linked in the table below.

.. table:: Private Elliptic Curve Data Structures
   :widths: 30 70

   +-----------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | Type/Location                                                                                       | Purpose                                                                                                                                                                                                                                              |
   +=====================================================================================================+======================================================================================================================================================================================================================================================+
   | ``PrimeOrderCurve``                                                                                 | Library-internal abstract interface to specific elliptic curve algorithm implementations.                                                                                                                                                            |
   | (:srcref:`code <[src/lib/math/pcurves]/pcurves.h>`)                                                 |                                                                                                                                                                                                                                                      |
   +-----------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | ``AffineCurvePoint``                                                                                | Curve specific representation of an affine point with coordinates :math:`x,y \in \mathbb{F}_p`.                                                                                                                                                      |
   | (:srcref:`code <[src/lib/math/pcurves/pcurves_impl]/pcurves_impl.h:706|AffineCurvePoint>`)          |                                                                                                                                                                                                                                                      |
   +-----------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | ``ProjectiveCurvePoint``                                                                            | Curve-specific implementation of a projective point using Jacobian coordinates :math:`x,y,z \in \mathbb{F}_p`. Provides foundational point algorithms, such as addition and doubling.                                                                |
   | (:srcref:`code <[src/lib/math/pcurves/pcurves_impl]/pcurves_impl.h:879|ProjectiveCurvePoint>`)      |                                                                                                                                                                                                                                                      |
   +-----------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | ``IntMod``                                                                                          | Curve-specific representation of an integer modulo a prime (either :math:`p` for field elements, or :math:`n` for scalar arithmetics). Provides foundational modular arithmetics algorithms and a customization point for curve-specific reductions. |
   | (:srcref:`code <[src/lib/math/pcurves/pcurves_impl]/pcurves_impl.h:145|IntMod>`)                    |                                                                                                                                                                                                                                                      |
   +-----------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | ``EllipticCurve``                                                                                   | Trait type for the concrete elliptic curve, its parameters and helper structures. Provides customization points for curve-specific field inversion algorithms.                                                                                       |
   | (:srcref:`code <[src/lib/math/pcurves/pcurves_impl]/pcurves_impl.h:1271|EllipticCurve>`)            |                                                                                                                                                                                                                                                      |
   +-----------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | ``BlindedScalarBits``                                                                               | Allows randomizing the representation of a scalar :math:`k` by adding the curve's prime order :math:`n` random :math:`m` times (:math:`k + n \cdot m`).                                                                                              |
   | (:srcref:`code <[src/lib/math/pcurves/pcurves_impl]/pcurves_impl.h:1450|BlindedScalarBits>`)        |                                                                                                                                                                                                                                                      |
   +-----------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | ``PrecomputedBaseMulTable``                                                                         | Represents a precomputed multiplication table to perform window multiplication by :math:`G`. The table is precomputed using a sequence of point additions of successive powers of the base point in a comb-like technique.                           |
   | (:srcref:`code <[src/lib/math/pcurves/pcurves_impl]/pcurves_impl.h:1605|PrecomputedBaseMulTable>`)  |                                                                                                                                                                                                                                                      |
   +-----------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | ``WindowedMulTable``                                                                                | Allows precomputing a multiplication table for generic point multiplication using a fixed window of some bit length :math:`W`. Then the usage of this precomputed table uses only double and add operations.                                         |
   | (:srcref:`code <[src/lib/math/pcurves/pcurves_impl]/pcurves_impl.h:1693|WindowedMulTable>`)         |                                                                                                                                                                                                                                                      |
   +-----------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | ``WindowedMul2Table``                                                                               | Allows precomputing a multiplication table for 2-ary point multiplication as a windowed variant of "Shamir's Trick" of some window bit length :math:`W`.                                                                                             |
   | (:srcref:`code <[src/lib/math/pcurves/pcurves_impl]/pcurves_impl.h:1805|WindowedMul2Table>`)        |                                                                                                                                                                                                                                                      |
   +-----------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Fundamental Elliptic Curve Algorithms
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Point Addition
~~~~~~~~~~~~~~

Implementations are provided for mixed projective and affine additions (see
:srcref:`[src/lib/math/pcurves/pcurves_impl]/pcurves_impl.h:958|add_mixed`) and
projective-projective additions (see
:srcref:`[src/lib/math/pcurves/pcurves_impl]/pcurves_impl.h:1009|add`). Both
follow the suggestions in [EFD]_.

Point Doubling
~~~~~~~~~~~~~~

Point doubling is implemented following the suggestions in [EFD]_ with
optimizations for curves with :math:`a = -3` or :math:`a = 0` (see
:srcref:`[src/lib/math/pcurves/pcurves_impl]/pcurves_impl.h:1135|dbl`).
Additionally, iterated point doubling is provided (see
:srcref:`[src/lib/math/pcurves/pcurves_impl]/pcurves_impl.h:1065|dbl_n`) with
similar special treatment for curves with :math:`a = -3` or :math:`a = 0`.

.. _pubkey/ecc/scalar_mul:

Multiplication of Scalar k and Point P
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Scalar multiplication of the form :math:`k \cdot P` is implemented using a
window method with precomputed points. For the curve's base point :math:`G` this
precomputation is performed only once and the table is cached for later uses by
the application. For the base point, a window size of 5 bits is used, for points
known only at runtime, the window size is 4 bits.

The online phase of the multiplication is implemented in a side-channel silent
manner ensuring table lookups aren't leaking information about the secret scalar
:math:`k`. The secret scalar is blinded with a random value :math:`m` of
bitlength :math:`length(n)/4` rounded up to the next word length of the target
machine. The scalar representation used in the multiplication is therefore
:math:`r = k + n \cdot m`, with :math:`n` being the curve's group order.
Finally, the projective Jacobian coordinate representation of the accumulator is
randomized for the first few window applications if a seeded random number
generator is available.

For links to the implementations see ``PrecomputedBaseMulTable`` and
``WindowedMulTable`` in the table above.

.. _pubkey/ecc/scalar_mul2:

2-ary Multiplication of Scalars p, q and Points X, Y
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The 2-ary multiplication of the form :math:`p \cdot X + q \cdot Y` is
implemented using a windowed variant of what is known as "Shamir's Trick". As an
optimization the multiplication table may be precomputed and cached. This is
particularly useful when performing multiple signature verifications under the
same public point :math:`Q`. In this case, the precomputation is performed for
:math:`X = G` (the group's generator) and :math:`Y = Q`. For such precomputed and
cached tables, the window size is 3 bits. For generic one-shot precomputations, it
is 2 bits.

The online phase of this 2-ary multiplication table *is not side-channel
silent*. However, it is used for only operations that don't handle secret values
such as signature verification. An additional implementation applying the same
countermeasures as the ordinary scalar multiplication is available. This may be
useful when implementing cryptographic schemes such as sPAKE, but it is
currently not used in the elliptic curve algorithms outlined below.

For links to the implementation, see ``WindowedMul2Table`` in the table above.

Key Generation
--------------

Botan provides the elliptic curve private key class ``EC_PrivateKey``, the
respective public key class ``EC_PublicKey``, and the key generation algorithm
in :srcref:`src/lib/pubkey/ecc_key/ecc_key.cpp:140|EC_PrivateKey`. To generate a
private key the constructor ``EC_PrivateKey(RandomNumberGenerator& rng, const
EC_Group& ec_group, bool with_modular_inverse)`` is called. The constructor
operates as follows:

.. admonition:: ``EC_PrivateKey()``

   **Input:**

   - ``rng``: random number generator
   - ``ec_group``: curve group parameters :math:`(a, b, p, G, n, h = 1)`
   - ``with_modular_inverse``: boolean parameter to generate a key pair for ECGDSA/ECKCDSA

   **Output:**

   -  EC_PrivateKey: :math:`d`
   -  EC_PublicKey: :math:`Q`

   **Steps:**

   1. Sample private value :math:`d` as a random number :math:`1 \leq d < n`
      using the algorithm described in Section :ref:`pubkey_param/rng`, where
      :math:`n` is the order of the base point G on the curve taken from the
      domain parameters.
   2. Compute public point :math:`Q` as :ref:`point multiplication
      <pubkey/ecc/scalar_mul>` :math:`d \cdot G`, where :math:`G` is the base
      point of the curve. Note that if the passed parameter
      ``with_modular_inverse`` is set to ``true``, the public point :math:`Q` is
      instead computed as :math:`d^{-1} \cdot G`. This is required for ECKDSA
      and ECGDSA key generation, but results in an invalid ECDH/ECDSA key.

Optionally ``EC_PublicKeys`` can be explicitly checked with a call to
``check_key``. The extensive check performs the following steps. Note that
``on_the_curve()`` is always automatically checked.

.. admonition:: ``EC_PublicKeys::check_key()``

   1. Check that the public point :math:`Q` is on the curve (function
      ``on_the_curve()``). This is done already when deserializing a public
      point into the library's internal structures. If the point does not
      satisfy the curve equation, an error is raised already then.
   2. Verify the ``ec_group`` by calling ``EC_Group::verify_group``. If the
      domain does not pass the verification, return false.
   3. Assure that the public point :math:`Q` is not the point at infinity.

**Conclusion:** The algorithm fulfills all requirements of [TR-03111]_.
The public key validation follows the requirements described in [ReqEC]_.

.. _pubkey/ecdh:

ECDH
----

The elliptic curve variant of the Diffie-Hellman key exchange is
implemented in :srcref:`src/lib/pubkey/ecdh/ecdh.cpp`.

Key Agreement
^^^^^^^^^^^^^

The shared secret is computed in
:srcref:`[src/lib/pubkey/ecdh]/ecdh.cpp:35|raw_agree`. The algorithm receives
the public point of the other party and computes the shared secret as follows:

.. admonition:: ``ECDH_KA_Operation::raw_agree()``

   **Input:**

   -  ``rng``: random number generator
   -  :math:`Q_b`: ECDH public point of the other party
   -  EC_Privatekey: :math:`d`, :math:`Q`, curve group parameters :math:`(a, b, p, G, n, h = 1)`

   **Output:**

   -  :math:`S`: shared ECDH secret value (byte-encoded x-coordinate of the secret point)

   **Steps:**

      1. Deserialize :math:`Q_b` from bytes. Note that this validates that the point is
         on the curve specified by the group parameters.
      2. Calculate the shared secret point :math:`S_{x,y} = d \cdot Q_b` (see :ref:`pubkey/ecc/scalar_mul`)
      3. Return the shared secret as :math:`S_x` serialized to bytes.

**Conclusion:** The implemented ECDH key agreement algorithm complies
with the algorithm shown in chapter 4.3.1 of [TR-03111]_ and thus fulfills
the ECDH criteria listed in [TR-02102-1]_, if a recommended curve was
chosen. Furthermore, it is recommended to utilize the optional KDF to
derive a symmetric key.


ECDSA
-----

The Digital Signature Algorithm over elliptic curves is implemented in
:srcref:`src/lib/pubkey/ecdsa/ecdsa.cpp`.
The implementation follows [X9.62]_ or [RFC6979]_ if the corresponding module is enabled.

Signature Schemes
^^^^^^^^^^^^^^^^^

Similarly to DSA, ECDSA uses the DL/ECSSA (EMSA1) [IEEE-1363-2000]_ signature scheme to
compute a representative of the message to be signed.

Signature Creation
^^^^^^^^^^^^^^^^^^

The signature generation algorithm works as follows (see
:srcref:`[src/lib/pubkey/ecdsa]/ecdsa.cpp:162|raw_sign`):

.. admonition:: ``ECDSA_Signature_Operation::raw_sign()``

   **Input:**

   -  ``rng``: random number generator
   -  :math:`H`: the hash value of the message to sign hashed via the hash function
      passed to the signature operation's constructor.
   -  EC_Privatekey: :math:`d`, :math:`Q`, curve group parameters :math:`(a, b, p, G, n, h = 1)`

   **Output:**

   -  (:math:`r`, :math:`s`): ECDSA signature

   **Steps:**

   1. Sample a random blinding scalar :math:`1 \leq b_1 < n` from ``rng`` and
      calculate its inverse :math:`b_1^{-1} \bmod n`

   1. :math:`e = H` and truncate :math:`e` to be at most :math:`length(n)` bits long.

   2. Generate parameter :math:`k` as a random number :math:`0 < k < n` using
      the algorithm described in Section :ref:`pubkey_param/rng` or as HMAC_DRBG
      output [RFC6979]_. If Botan is compiled with the module RFC6979 the
      HMAC_DRBG is used, otherwise :math:`k` is sampled from the passed random
      number generator ``rng``.

   3. :math:`r = R_x \bmod n` where :math:`R_x` is the x-coordinate of the affine point
      :math:`R_{x,y} = k \cdot G` (see :ref:`pubkey/ecc/scalar_mul`).

   4. Compute :math:`k^{-1} = (b_1 \cdot k)^{-1} \cdot b_1` using the blinding
      value :math:`b_1`. The inversion either uses Fermat's little theorem or a
      curve-specific addition chain if available.

   5. Square the blinding values :math:`b_1` and :math:`b_1^{-1} \bmod n` to
      obtain new blinding values :math:`b_2` and :math:`b_2^{-1} \bmod n`. This
      is done to avoid re-sampling/re-inverting the blinding values. When using
      RFC6979 we might not have a seeded random number generator handy in this
      phase of the signature creation.

   6. Compute :math:`s = k^{-1} \cdot {b_2}^{-1} \cdot (d \cdot b_2 \cdot r + e \cdot b_2)`

   7. Return :math:`(r, s)` if :math:`r \neq 0` and :math:`s \neq 0`. Otherwise throw an exception.

**Remark:** If Botan is built with the RFC6979 module, it implements
deterministic ECDSA signatures, which are not covered by [TR-03111]_. In
this case the implemented ECDSA signature algorithm is not [FIPS-186-4]_
conform. However, the RFC6979 module is prohibited in the BSI module
policy.

Signature Verification
^^^^^^^^^^^^^^^^^^^^^^

The signature verification algorithm works as follows (see
:srcref:`[src/lib/pubkey/ecdsa]/ecdsa.cpp:214|verify`):

.. admonition:: ``ECDSA_Verification_Operation::verify()``

   **Input:**

   -  :math:`H`: the hash value of the signed message hashed via the hash function
      passed to the verification operation's constructor
   -  EC_Publickey: :math:`Q`, curve group parameters :math:`(a, b, p, G, n, h = 1)`
   -  :math:`(r, s)`: ECDSA signature

   **Output:**

   -  ``true``, if the signature for digest :math:`H` is valid. ``false`` otherwise.

   **Steps:**

   1. Deserialize the signature into :math:`r` and :math:`s`

      1. Verify the passed signature has a valid length. Otherwise, return ``false``.
      2. Verify that :math:`0<r<n` and :math:`0<s<n`. Otherwise, return ``false``.

   3. :math:`e = H` and truncate :math:`e` to be at most :math:`length(n)` bits long.
   4. Calculate :math:`s^{-1} \bmod n` (potentially using a variable time inversion algorithm)
   5. Check if :math:`r = R_x \bmod n` with :math:`R_{x,y} = (e \cdot s^{-1} \bmod n) \cdot G + (r \cdot s^{-1} \bmod n) \cdot Q`.
      This operation is *not side-channel silent* (see :ref:`pubkey/ecc/scalar_mul2`).
   6. If the equation above holds and :math:`R_{x,y}` is not the point at
      infinity, return ``true``. Otherwise, return ``false``.


ECKCDSA
-------

The Korean Certificate-based Digital Signature Algorithm over elliptic
curves is implemented in :srcref:`src/lib/pubkey/eckcdsa/eckcdsa.cpp`. The
implementation follows [ISO-14888-3]_.

Signature Schemes
^^^^^^^^^^^^^^^^^

Unlike other DSA variants, ECKCDSA does not use the DL/ECSSA (EMSA1) [IEEE-1363-2000]_
signature scheme to compute a representative of the message to be
signed.
Instead, besides the message itself,
it also includes the public key in the representative.

Signature Creation
^^^^^^^^^^^^^^^^^^

The signature generation algorithm works as follows (see
:srcref:`[src/lib/pubkey/eckcdsa]/eckcdsa.cpp:163|raw_sign`):

.. admonition:: ``ECKCDSA_Signature_Operation::raw_sign()``

   **Input:**

   -  ``m``: raw bytes to sign (the hash-code ``H`` in  [ISO-14888-3]_,
      which is the truncated hash from the public key and message)
   -  EC_Privatekey: :math:`d`, :math:`Q`, curve group parameters :math:`(a, b, p, G, n, h = 1)`
   -  ``rng``: random number generator

   **Output:**

   -  (r,s): ECKCDSA signature

   **Steps:**

   1. Sample parameter k as a random number :math:`0 < k < n` from ``rng`` using
      the algorithm described in Section :ref:`pubkey_param/rng`.
   2. Compute point :math:`W_{x,y} = k \cdot G` (see :ref:`pubkey/ecc/scalar_mul`)
   3. Compute the witness :math:`r = h(W_x)` , where :math:`h` is the hash
      function used in the current instance of the signature scheme.
   4. If the output length of the hash function :math:`h` exceeds the size of
      the group order, truncate the *low side* in :math:`r` on a byte level to
      the size of the group order. This means bytes in :math:`r` are discarded
      starting from the beginning of the byte sequence.
   5. Compute :math:`s = d \cdot ((k - (r \oplus m)) \bmod n)`.
   6. If :math:`s = 0`, the algorithm terminates with an error.
   7. Return ECKCDSA signature (r,s).

Signature Verification
^^^^^^^^^^^^^^^^^^^^^^

The signature verification algorithm works as follows (see
:srcref:`[src/lib/pubkey/eckcdsa]/eckcdsa.cpp:235|verify`):

.. admonition:: ``ECKCDSA_Verification_Operation::verify()``

   **Input:**

   -  ``m``: raw bytes to verify (the hash-code ``H`` in  [ISO-14888-3]_,
      which is the truncated hash from the public key and message)
   -  EC_Publickey: :math:`Q`, curve group parameters :math:`(a, b, p, G, n, h = 1)`
   -  :math:`(r, s)`: ECKCDSA signature

   **Output:**

   -  ``true``, if the signature for message ``m`` is valid. ``false`` otherwise

   **Steps:**

   1. Deserialize the signature into :math:`r` and :math:`s`

      1. Perform preliminary parameter checks, and
      2. Verify that :math:`0<s<n` applies. Return ``false`` otherwise.

   2. Compute :math:`e=r \oplus m \bmod n`.
   3. Compute point :math:`W_{x,y}=s \cdot Q+e \cdot G`. This operation is *not
      side-channel silent* (see :ref:`pubkey/ecc/scalar_mul2`).
   4. Recompute the witness :math:`r'=h(W_x)`,
      where :math:`h` is the hash function used in the current instance of the signature scheme.
   5. If the output length of the hash function :math:`h` exceeds the size of the group order,
      truncate the *low side* in :math:`r` on a byte level to the size of the group order.
      This means bytes in :math:`r` are discarded starting from the beginning of the byte sequence.
   6. Return ``true`` if the recomputed witness :math:`r'` is equal to
      the witness :math:`r` inside the signature. Otherwise return ``false``.


ECGDSA
------

Signature Schemes
^^^^^^^^^^^^^^^^^

The German Digital Signature Algorithm over elliptic curves is
implemented in :srcref:`src/lib/pubkey/ecgdsa/ecgdsa.cpp`. The implementation
follows [ISO-14888-3]_.

Signature Creation
^^^^^^^^^^^^^^^^^^

The signature generation algorithm works as follows (see
:srcref:`[src/lib/pubkey/ecgdsa]/ecgdsa.cpp:60|raw_sign`):

.. admonition:: ``ECGDSA_Signature_Operation::raw_sign()``

   **Input:**

   -  :math:`m`: digest of message bytes (using a user-defined hash function)
      hash function)
   -  EC_Privatekey: :math:`d`, :math:`Q`, curve group parameters :math:`(a, b, p, G, n, h = 1)`
   -  ``rng``: random number generator

   **Output:**

   -  (r,s): ECGDSA signature

   **Steps:**

   1. Truncate :math:`m` to be at most :math:`length(n)` bits long and interpret
      it as a big-endian encoded scalar.
   2. Sample parameter :math:`k` as a random number :math:`0 < k < n` from ``rng``
      using the algorithm described in Section :ref:`pubkey_param/rng`.
   3. Compute point :math:`W_{x,y} = k \cdot G` (see :ref:`pubkey/ecc/scalar_mul`)
   4. Set :math:`r = W_x \bmod n`
   5. Compute :math:`s = d \cdot (k \cdot r - m) \bmod n`.
   6. If :math:`s = 0` or :math:`r = 0` applies, the algorithm terminates with
      an error.
   7. Return ECGDSA signature :math:`(r,s)`.

Signature Verification
^^^^^^^^^^^^^^^^^^^^^^

The signature verification algorithm works as follows (see
:srcref:`[src/lib/pubkey/ecgdsa]/ecgdsa.cpp:97|verify`):

.. admonition:: ``ECGDSA_Verification_Operation::verify()``

   **Input:**

   -  :math:`m`: digest of message bytes (using a user-defined hash function)
   -  EC_Publickey: :math:`Q`, curve group parameters :math:`(a, b, p, G, n, h = 1)`
   -   :math:`(r, s)`: ECGDSA signature

   **Output:**

   -  ``true``, if the signature for message ``m`` is valid. ``false`` otherwise

   **Steps:**

   1. Deserialize the signature into :math:`r` and :math:`s`

      1. Perform preliminary parameter checks and verify that
         :math:`0 < r < n` and :math:`0 < s < n` applies.

   2. Truncate :math:`m` to be at most :math:`length(n)` bits long.
   3. Compute :math:`r^{-1} \bmod n` (potentially using a variable time inversion algorithm)
   4. Compute :math:`v_{1} = r^{-1} \cdot m \bmod n`
      and :math:`v_{2} = r^{-1} \cdot s \bmod n`.
   5. Compute point :math:`W_{x,y} = v_{1} \cdot G + v_{2} \cdot Q`. This operation is *not side-channel silent* (see :ref:`pubkey/ecc/scalar_mul2`)
   6. Return ``true`` if :math:`r \equiv W_x \bmod n` applies, otherwise ``false``.
