Security and Vulnerabilities
============================

.. _secinfo/kyberslash:

KyberSlash
----------

This is a series of potential side channel vulnerabilities discovered in several
software implementations of Kyber. It was initially discovered by Goutam
Tamvada, Franziskus Kiefer, and Karthikeyan Bhargavan and later `independently
reported by Daniel Bernstein
<https://groups.google.com/a/list.nist.gov/g/pqc-forum/c/hWqFJCucuj4/m/-Z-jm_k9AAAJ>`_.
A `similar issue was discovered by Prasanna Ravi and Matthias Kannwischer
<https://groups.google.com/a/list.nist.gov/g/pqc-forum/c/ldX0ThYJuBo/m/ovODsdY7AwAJ>`_
in a different part of the implementation shortly after.

The timing side channels stem from divisions by a constant integer (`q`) in the
C++ code. On some target configurations (compiler, processor architecture, build
flags) this division operation is represented by a variable-time division
instruction, which leaks information.

Affected are the compression of Kyber's shared secret value during
decapsulation, as well as the compression of the ciphertext during
encapsulation. Both side channels may leak enough sensitive information to be
exploitable by an attacker under certain circumstances.

These side channels are present in Botan 3.0.0 to 3.2.0 and were fixed in
|botan_version|. The fix essentially hard-codes the division by `q` as a series
of constant-time bit shift and multiplication operations. See also :ref:`changes/fixes`.

.. _secinfo/oversized_ecc:

Oversized elliptic curve parameters cause DoS
---------------------------------------------

For custom elliptic curves, Botan didn't reject an oversized parameter ``p``.
Instead, it would attempt to verify the primality of the parameter. Especially for
maliciously large parameters with thousands of bits, this could waste a
significant amount of computation time. Starting with Botan |botan_version|, the
maximum size of ``p`` is limited to 1024 bits.

A vulnerable application would have to invoke one of the following ``EC_Group``
constructors or factory methods with parameters from an untrusted source:

* ``EC_Group::EC_Group(std::string_view pem_or_oid)``
* ``EC_Group::EC_Group(const uint8_t& ber[], size_t ber_len)``
* ``EC_Group::EC_Group(const std::vector<uint8_t>& ber)``
* ``EC_Group::EC_Group_from_PEM(std::string_view pem)``.

Please explicitly note that all of the above constructors accept both an
encoded OID (of a named curve) or encoded parameters of a custom curve. The
disambiguation is performed internally. This could allow an attacker to
masquerade a custom curve as an OID of a named curve and exploit the
vulnerability.

Note that these constructors are also called internally and may receive
user-provided or potentially untrusted data. For instance, when loading a
maliciously crafted key in an ASN.1 container or even embedded into an X.509
certificate.

For a vulnerable server requiring TLS client authentication, this
might be a feasible denial of service amplifier without requiring the attacker
to be in a privileged network location. An attacker on the network path could
mount a similar attack by impersonating the server and sending a malicious
certificate to waste CPU time on the client and cause a denial of service.

Some of the interfaces that internally call the above constructors are:

* ``create_private_key(std::string_view alg_name, RandomNumberGenerator& rng,
  std::string_view params, std::string_view provider)`` where the `params`
  argument may contain custom curve parameters.
* ``EC_PrivateKey(const AlgorithmIdentifier& alg_id, std::span<uint8_t>
  key_bits, bool with_modular_inverse)`` where the `alg_id` argument may contain
  encoded custom curve parameters in its `parameters` field.
* ``EC_PublicKey(const AlgorithmIdentifier& alg_id, std::span<uint8_t>
  key_bits)`` where the `alg_id` argument may contain encoded custom curve
  parameters in its `parameters` field.
* ``X509::load_key(...)`` (all of its overloads), with a custom curve encoded
  into a key container format. This is used to load public keys embedded in
  X.509 certificates.

This issue was reported to the maintainer by Bing Shi.

.. _secinfo/binary_gcd:

Faulty gcd() implementation
---------------------------

As shown by the OSS-Fuzz project, Botan's previous implementation to find the
greatest common denominator of two arbitrarily sized integers generated an error
for certain inputs. The GCD algorithm was based on "safegcd" [SAFEGCD]_, but
with a slight adaption to avoid the requirement of constant-time arithmetics on
signed integers. This adaption violated the algorithm's termination assumptions,
causing the sporadic error.

Most notably, the gcd() function is used in the RSA key generation. As a result,
key generation might have sporadically failed with an exception. In the worst
case this could have caused a bias in the RSA key pairs generated by Botan.
However, we are not aware of any failures in a production environment.

As a permanent fix, Botan |botan_version| uses the binary GCD algorithm
[BINARYGCD]_, which does not require constant-time arithmetics on signed integers
and provides a termination assumption that is much easier to reason about.
Additionally, the new gcd() is more resistant against timing side channels than the previous version.

This issue was found by the OSS-Fuzz project under the `ticket 66162
<https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=66162>`_.
